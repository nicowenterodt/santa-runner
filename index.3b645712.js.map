{"mappings":"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","sources":["<anon>","src/engine.js"],"sourcesContent":["// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// extract from chromium source code by @liuwayong\n(function() {\n    'use strict';\n    /**\n     * T-Rex runner.\n     * @param {string} outerContainerId Outer containing element id.\n     * @param {Object} opt_config\n     * @constructor\n     * @export\n     */ function Runner1(outerContainerId, opt_config) {\n        // Singleton\n        if (Runner1.instance_) return Runner1.instance_;\n        Runner1.instance_ = this;\n        this.outerContainerEl = document.querySelector(outerContainerId);\n        this.containerEl = null;\n        this.snackbarEl = null;\n        this.detailsButton = this.outerContainerEl.querySelector('#details-button');\n        this.config = opt_config || Runner1.config;\n        this.dimensions = Runner1.defaultDimensions;\n        this.canvas = null;\n        this.canvasCtx = null;\n        this.tRex = null;\n        this.distanceMeter = null;\n        this.distanceRan = 0;\n        this.highestScore = 0;\n        this.time = 0;\n        this.runningTime = 0;\n        this.msPerFrame = 1000 / FPS;\n        this.currentSpeed = this.config.SPEED;\n        this.obstacles = [];\n        this.activated = false; // Whether the easter egg has been activated.\n        this.playing = false; // Whether the game is currently in play state.\n        this.crashed = false;\n        this.paused = false;\n        this.inverted = false;\n        this.invertTimer = 0;\n        this.resizeTimerId_ = null;\n        this.playCount = 0;\n        // Sound FX.\n        this.audioBuffer = null;\n        this.soundFx = {};\n        // Global web audio context for playing sounds.\n        this.audioContext = null;\n        // Images.\n        this.images = {};\n        this.imagesLoaded = 0;\n        if (this.isDisabled()) this.setupDisabledRunner();\n        else this.loadImages();\n    }\n    window['Runner'] = Runner1;\n    /**\n     * Default game width.\n     * @const\n     */ var DEFAULT_WIDTH = 600;\n    /**\n     * Frames per second.\n     * @const\n     */ var FPS = 60;\n    /** @const */ var IS_HIDPI = window.devicePixelRatio > 1;\n    /** @const */ var IS_IOS = /iPad|iPhone|iPod/.test(window.navigator.platform);\n    /** @const */ var IS_MOBILE = /Android/.test(window.navigator.userAgent) || IS_IOS;\n    /** @const */ var IS_TOUCH_ENABLED = 'ontouchstart' in window;\n    /**\n     * Default game configuration.\n     * @enum {number}\n     */ Runner1.config = {\n        ACCELERATION: 0.001,\n        BG_CLOUD_SPEED: 0.2,\n        BOTTOM_PAD: 10,\n        CLEAR_TIME: 3000,\n        CLOUD_FREQUENCY: 0.5,\n        GAMEOVER_CLEAR_TIME: 750,\n        GAP_COEFFICIENT: 0.6,\n        GRAVITY: 0.6,\n        INITIAL_JUMP_VELOCITY: 12,\n        INVERT_FADE_DURATION: 12000,\n        INVERT_DISTANCE: 700,\n        MAX_BLINK_COUNT: 3,\n        MAX_CLOUDS: 6,\n        MAX_OBSTACLE_LENGTH: 3,\n        MAX_OBSTACLE_DUPLICATION: 2,\n        MAX_SPEED: 13,\n        MIN_JUMP_HEIGHT: 35,\n        MOBILE_SPEED_COEFFICIENT: 1.2,\n        RESOURCE_TEMPLATE_ID: 'audio-resources',\n        SPEED: 6,\n        SPEED_DROP_COEFFICIENT: 3,\n        ARCADE_MODE_INITIAL_TOP_POSITION: 100,\n        ARCADE_MODE_TOP_POSITION_PERCENT: 0\n    };\n    /**\n     * Default dimensions.\n     * @enum {string}\n     */ Runner1.defaultDimensions = {\n        WIDTH: DEFAULT_WIDTH,\n        HEIGHT: 150\n    };\n    /**\n     * CSS class names.\n     * @enum {string}\n     */ Runner1.classes = {\n        ARCADE_MODE: 'arcade-mode',\n        CANVAS: 'runner-canvas',\n        CONTAINER: 'runner-container',\n        CRASHED: 'crashed',\n        ICON: 'icon-offline',\n        INVERTED: 'inverted',\n        SNACKBAR: 'snackbar',\n        SNACKBAR_SHOW: 'snackbar-show',\n        TOUCH_CONTROLLER: 'controller'\n    };\n    /**\n     * Sprite definition layout of the spritesheet.\n     * @enum {Object}\n     */ Runner1.spriteDefinition = {\n        LDPI: {\n            CACTUS_LARGE: {\n                x: 332,\n                y: 2\n            },\n            CACTUS_SMALL: {\n                x: 228,\n                y: 2\n            },\n            CLOUD: {\n                x: 86,\n                y: 2\n            },\n            HORIZON: {\n                x: 2,\n                y: 54\n            },\n            MOON: {\n                x: 484,\n                y: 2\n            },\n            PTERODACTYL: {\n                x: 134,\n                y: 2\n            },\n            RESTART: {\n                x: 2,\n                y: 2\n            },\n            TEXT_SPRITE: {\n                x: 655,\n                y: 2\n            },\n            TREX: {\n                x: 848,\n                y: 2\n            },\n            STAR: {\n                x: 645,\n                y: 2\n            }\n        },\n        HDPI: {\n            CACTUS_LARGE: {\n                x: 652,\n                y: 2\n            },\n            CACTUS_SMALL: {\n                x: 446,\n                y: 2\n            },\n            CLOUD: {\n                x: 166,\n                y: 2\n            },\n            HORIZON: {\n                x: 2,\n                y: 104\n            },\n            MOON: {\n                x: 954,\n                y: 2\n            },\n            PTERODACTYL: {\n                x: 260,\n                y: 2\n            },\n            RESTART: {\n                x: 2,\n                y: 2\n            },\n            TEXT_SPRITE: {\n                x: 1294,\n                y: 2\n            },\n            TREX: {\n                x: 1678,\n                y: 2\n            },\n            STAR: {\n                x: 1276,\n                y: 2\n            }\n        }\n    };\n    /**\n     * Sound FX. Reference to the ID of the audio tag on interstitial page.\n     * @enum {string}\n     */ Runner1.sounds = {\n        BUTTON_PRESS: 'offline-sound-press',\n        HIT: 'offline-sound-hit',\n        SCORE: 'offline-sound-reached'\n    };\n    /**\n     * Key code mapping.\n     * @enum {Object}\n     */ Runner1.keycodes = {\n        JUMP: {\n            '38': 1,\n            '32': 1\n        },\n        DUCK: {\n            '40': 1\n        },\n        RESTART: {\n            '13': 1\n        } // Enter\n    };\n    /**\n     * Runner event names.\n     * @enum {string}\n     */ Runner1.events = {\n        ANIM_END: 'webkitAnimationEnd',\n        CLICK: 'click',\n        KEYDOWN: 'keydown',\n        KEYUP: 'keyup',\n        MOUSEDOWN: 'mousedown',\n        MOUSEUP: 'mouseup',\n        RESIZE: 'resize',\n        TOUCHEND: 'touchend',\n        TOUCHSTART: 'touchstart',\n        VISIBILITY: 'visibilitychange',\n        BLUR: 'blur',\n        FOCUS: 'focus',\n        LOAD: 'load'\n    };\n    Runner1.prototype = {\n        /**\n         * Whether the easter egg has been disabled. CrOS enterprise enrolled devices.\n         * @return {boolean}\n         */ isDisabled: function() {\n            // return loadTimeData && loadTimeData.valueExists('disabledEasterEgg');\n            return false;\n        },\n        /**\n         * For disabled instances, set up a snackbar with the disabled message.\n         */ setupDisabledRunner: function() {\n            this.containerEl = document.createElement('div');\n            this.containerEl.className = Runner1.classes.SNACKBAR;\n            this.containerEl.textContent = loadTimeData.getValue('disabledEasterEgg');\n            this.outerContainerEl.appendChild(this.containerEl);\n            // Show notification when the activation key is pressed.\n            document.addEventListener(Runner1.events.KEYDOWN, (function(e) {\n                if (Runner1.keycodes.JUMP[e.keyCode]) {\n                    this.containerEl.classList.add(Runner1.classes.SNACKBAR_SHOW);\n                    document.querySelector('.icon').classList.add('icon-disabled');\n                }\n            }).bind(this));\n        },\n        /**\n         * Setting individual settings for debugging.\n         * @param {string} setting\n         * @param {*} value\n         */ updateConfigSetting: function(setting, value) {\n            if (setting in this.config && value != undefined) {\n                this.config[setting] = value;\n                switch(setting){\n                    case 'GRAVITY':\n                    case 'MIN_JUMP_HEIGHT':\n                    case 'SPEED_DROP_COEFFICIENT':\n                        this.tRex.config[setting] = value;\n                        break;\n                    case 'INITIAL_JUMP_VELOCITY':\n                        this.tRex.setJumpVelocity(value);\n                        break;\n                    case 'SPEED':\n                        this.setSpeed(value);\n                        break;\n                }\n            }\n        },\n        /**\n         * Cache the appropriate image sprite from the page and get the sprite sheet\n         * definition.\n         */ loadImages: function() {\n            if (IS_HIDPI) {\n                Runner1.imageSprite = document.getElementById('offline-resources-2x');\n                this.spriteDef = Runner1.spriteDefinition.HDPI;\n            } else {\n                Runner1.imageSprite = document.getElementById('offline-resources-1x');\n                this.spriteDef = Runner1.spriteDefinition.LDPI;\n            }\n            if (Runner1.imageSprite.complete) this.init();\n            else // If the images are not yet loaded, add a listener.\n            Runner1.imageSprite.addEventListener(Runner1.events.LOAD, this.init.bind(this));\n        },\n        /**\n         * Load and decode base 64 encoded sounds.\n         */ loadSounds: function() {\n            if (!IS_IOS) {\n                this.audioContext = new AudioContext();\n                var resourceTemplate = document.getElementById(this.config.RESOURCE_TEMPLATE_ID).content;\n                for(var sound in Runner1.sounds){\n                    var soundSrc = resourceTemplate.getElementById(Runner1.sounds[sound]).src;\n                    soundSrc = soundSrc.substr(soundSrc.indexOf(',') + 1);\n                    var buffer = decodeBase64ToArrayBuffer(soundSrc);\n                    // Async, so no guarantee of order in array.\n                    this.audioContext.decodeAudioData(buffer, (function(index, audioData) {\n                        this.soundFx[index] = audioData;\n                    }).bind(this, sound));\n                }\n            }\n        },\n        /**\n         * Sets the game speed. Adjust the speed accordingly if on a smaller screen.\n         * @param {number} opt_speed\n         */ setSpeed: function(opt_speed) {\n            var speed = opt_speed || this.currentSpeed;\n            // Reduce the speed on smaller mobile screens.\n            if (this.dimensions.WIDTH < DEFAULT_WIDTH) {\n                var mobileSpeed = speed * this.dimensions.WIDTH / DEFAULT_WIDTH * this.config.MOBILE_SPEED_COEFFICIENT;\n                this.currentSpeed = mobileSpeed > speed ? speed : mobileSpeed;\n            } else if (opt_speed) this.currentSpeed = opt_speed;\n        },\n        /**\n         * Game initialiser.\n         */ init: function() {\n            // Hide the static icon.\n            document.querySelector('.' + Runner1.classes.ICON).style.visibility = 'hidden';\n            this.adjustDimensions();\n            this.setSpeed();\n            this.containerEl = document.createElement('div');\n            this.containerEl.className = Runner1.classes.CONTAINER;\n            // Player canvas container.\n            this.canvas = createCanvas(this.containerEl, this.dimensions.WIDTH, this.dimensions.HEIGHT, Runner1.classes.PLAYER);\n            this.canvasCtx = this.canvas.getContext('2d');\n            this.canvasCtx.fillStyle = '#f7f7f7';\n            this.canvasCtx.fill();\n            Runner1.updateCanvasScaling(this.canvas);\n            // Horizon contains clouds, obstacles and the ground.\n            this.horizon = new Horizon(this.canvas, this.spriteDef, this.dimensions, this.config.GAP_COEFFICIENT);\n            // Distance meter\n            this.distanceMeter = new DistanceMeter(this.canvas, this.spriteDef.TEXT_SPRITE, this.dimensions.WIDTH);\n            // Draw t-rex\n            this.tRex = new Trex(this.canvas, this.spriteDef.TREX);\n            this.outerContainerEl.appendChild(this.containerEl);\n            if (IS_MOBILE) this.createTouchController();\n            this.startListening();\n            this.update();\n            window.addEventListener(Runner1.events.RESIZE, this.debounceResize.bind(this));\n        },\n        /**\n         * Create the touch controller. A div that covers whole screen.\n         */ createTouchController: function() {\n            this.touchController = document.createElement('div');\n            this.touchController.className = Runner1.classes.TOUCH_CONTROLLER;\n            this.outerContainerEl.appendChild(this.touchController);\n        },\n        /**\n         * Debounce the resize event.\n         */ debounceResize: function() {\n            if (!this.resizeTimerId_) this.resizeTimerId_ = setInterval(this.adjustDimensions.bind(this), 250);\n        },\n        /**\n         * Adjust game space dimensions on resize.\n         */ adjustDimensions: function() {\n            clearInterval(this.resizeTimerId_);\n            this.resizeTimerId_ = null;\n            var boxStyles = window.getComputedStyle(this.outerContainerEl);\n            var padding = Number(boxStyles.paddingLeft.substr(0, boxStyles.paddingLeft.length - 2));\n            this.dimensions.WIDTH = this.outerContainerEl.offsetWidth - padding * 2;\n            this.dimensions.WIDTH = Math.min(DEFAULT_WIDTH, this.dimensions.WIDTH); //Arcade Mode\n            if (this.activated) this.setArcadeModeContainerScale();\n            // Redraw the elements back onto the canvas.\n            if (this.canvas) {\n                this.canvas.width = this.dimensions.WIDTH;\n                this.canvas.height = this.dimensions.HEIGHT;\n                Runner1.updateCanvasScaling(this.canvas);\n                this.distanceMeter.calcXPos(this.dimensions.WIDTH);\n                this.clearCanvas();\n                this.horizon.update(0, 0, true);\n                this.tRex.update(0);\n                // Outer container and distance meter.\n                if (this.playing || this.crashed || this.paused) {\n                    this.containerEl.style.width = this.dimensions.WIDTH + 'px';\n                    this.containerEl.style.height = this.dimensions.HEIGHT + 'px';\n                    this.distanceMeter.update(0, Math.ceil(this.distanceRan));\n                    this.stop();\n                } else this.tRex.draw(0, 0);\n                // Game over panel.\n                if (this.crashed && this.gameOverPanel) {\n                    this.gameOverPanel.updateDimensions(this.dimensions.WIDTH);\n                    this.gameOverPanel.draw();\n                }\n            }\n        },\n        /**\n         * Play the game intro.\n         * Canvas container width expands out to the full width.\n         */ playIntro: function() {\n            if (!this.activated && !this.crashed) {\n                this.playingIntro = true;\n                this.tRex.playingIntro = true;\n                // CSS animation definition.\n                var keyframes = \"@-webkit-keyframes intro { from { width:\" + Trex.config.WIDTH + 'px }' + 'to { width: ' + this.dimensions.WIDTH + 'px }' + '}';\n                // create a style sheet to put the keyframe rule in\n                // and then place the style sheet in the html head\n                var sheet = document.createElement('style');\n                sheet.innerHTML = keyframes;\n                document.head.appendChild(sheet);\n                this.containerEl.addEventListener(Runner1.events.ANIM_END, this.startGame.bind(this));\n                this.containerEl.style.webkitAnimation = 'intro .4s ease-out 1 both';\n                this.containerEl.style.width = this.dimensions.WIDTH + 'px';\n                // if (this.touchController) {\n                //     this.outerContainerEl.appendChild(this.touchController);\n                // }\n                this.playing = true;\n                this.activated = true;\n            } else if (this.crashed) this.restart();\n        },\n        /**\n         * Update the game status to started.\n         */ startGame: function() {\n            this.setArcadeMode();\n            this.runningTime = 0;\n            this.playingIntro = false;\n            this.tRex.playingIntro = false;\n            this.containerEl.style.webkitAnimation = '';\n            this.playCount++;\n            document.querySelector('#helpstart').style.visibility = 'hidden';\n            // Handle tabbing off the page. Pause the current game.\n            document.addEventListener(Runner1.events.VISIBILITY, this.onVisibilityChange.bind(this));\n            window.addEventListener(Runner1.events.BLUR, this.onVisibilityChange.bind(this));\n            window.addEventListener(Runner1.events.FOCUS, this.onVisibilityChange.bind(this));\n        },\n        clearCanvas: function() {\n            this.canvasCtx.clearRect(0, 0, this.dimensions.WIDTH, this.dimensions.HEIGHT);\n        },\n        /**\n         * Update the game frame and schedules the next one.\n         */ update: function() {\n            this.updatePending = false;\n            var now = getTimeStamp();\n            var deltaTime = now - (this.time || now);\n            this.time = now;\n            if (this.playing) {\n                this.clearCanvas();\n                if (this.tRex.jumping) this.tRex.updateJump(deltaTime);\n                this.runningTime += deltaTime;\n                var hasObstacles = this.runningTime > this.config.CLEAR_TIME;\n                // First jump triggers the intro.\n                if (this.tRex.jumpCount == 1 && !this.playingIntro) this.playIntro();\n                // The horizon doesn't move until the intro is over.\n                if (this.playingIntro) this.horizon.update(0, this.currentSpeed, hasObstacles);\n                else {\n                    deltaTime = !this.activated ? 0 : deltaTime;\n                    this.horizon.update(deltaTime, this.currentSpeed, hasObstacles, this.inverted);\n                }\n                // Check for collisions.\n                var collision = hasObstacles && checkForCollision(this.horizon.obstacles[0], this.tRex);\n                if (!collision) {\n                    this.distanceRan += this.currentSpeed * deltaTime / this.msPerFrame;\n                    if (this.currentSpeed < this.config.MAX_SPEED) this.currentSpeed += this.config.ACCELERATION;\n                } else this.gameOver();\n                var playAchievementSound = this.distanceMeter.update(deltaTime, Math.ceil(this.distanceRan));\n                if (playAchievementSound) this.playSound(this.soundFx.SCORE);\n                // Night mode.\n                if (this.invertTimer > this.config.INVERT_FADE_DURATION) {\n                    this.invertTimer = 0;\n                    this.invertTrigger = false;\n                    this.invert();\n                } else if (this.invertTimer) this.invertTimer += deltaTime;\n                else {\n                    var actualDistance = this.distanceMeter.getActualDistance(Math.ceil(this.distanceRan));\n                    if (actualDistance > 0) {\n                        this.invertTrigger = !(actualDistance % this.config.INVERT_DISTANCE);\n                        if (this.invertTrigger && this.invertTimer === 0) {\n                            this.invertTimer += deltaTime;\n                            this.invert();\n                        }\n                    }\n                }\n            }\n            if (this.playing || !this.activated && this.tRex.blinkCount < Runner1.config.MAX_BLINK_COUNT) {\n                this.tRex.update(deltaTime);\n                this.scheduleNextUpdate();\n            }\n        },\n        /**\n         * Event handler.\n         */ handleEvent: function(e) {\n            return (function(evtType, events) {\n                switch(evtType){\n                    case events.KEYDOWN:\n                    case events.TOUCHSTART:\n                    case events.MOUSEDOWN:\n                        this.onKeyDown(e);\n                        break;\n                    case events.KEYUP:\n                    case events.TOUCHEND:\n                    case events.MOUSEUP:\n                        this.onKeyUp(e);\n                        break;\n                }\n            }).bind(this)(e.type, Runner1.events);\n        },\n        /**\n         * Bind relevant key / mouse / touch listeners.\n         */ startListening: function() {\n            // Keys.\n            document.addEventListener(Runner1.events.KEYDOWN, this);\n            document.addEventListener(Runner1.events.KEYUP, this);\n            if (IS_MOBILE) {\n                // Mobile only touch devices.\n                this.touchController.addEventListener(Runner1.events.TOUCHSTART, this);\n                this.touchController.addEventListener(Runner1.events.TOUCHEND, this);\n                this.containerEl.addEventListener(Runner1.events.TOUCHSTART, this);\n            }\n            // Mouse.\n            document.addEventListener(Runner1.events.MOUSEDOWN, this);\n            document.addEventListener(Runner1.events.MOUSEUP, this);\n        },\n        /**\n         * Remove all listeners.\n         */ stopListening: function() {\n            document.removeEventListener(Runner1.events.KEYDOWN, this);\n            document.removeEventListener(Runner1.events.KEYUP, this);\n            if (IS_MOBILE) {\n                this.touchController.removeEventListener(Runner1.events.TOUCHSTART, this);\n                this.touchController.removeEventListener(Runner1.events.TOUCHEND, this);\n                this.containerEl.removeEventListener(Runner1.events.TOUCHSTART, this);\n            } else {\n                document.removeEventListener(Runner1.events.MOUSEDOWN, this);\n                document.removeEventListener(Runner1.events.MOUSEUP, this);\n            }\n        },\n        /**\n         * Process keydown.\n         * @param {Event} e\n         */ onKeyDown: function(e) {\n            // Prevent native page scrolling whilst tapping on mobile.\n            if (IS_MOBILE && this.playing) e.preventDefault();\n            if (e.target != this.detailsButton) {\n                if (!this.crashed && (Runner1.keycodes.JUMP[e.keyCode] || e.type == Runner1.events.TOUCHSTART || e.type == Runner1.events.MOUSEDOWN)) {\n                    if (!this.playing) {\n                        this.loadSounds();\n                        this.playing = true;\n                        this.update();\n                        if (window.errorPageController) errorPageController.trackEasterEgg();\n                    }\n                    //  Play sound effect and jump on starting the game for the first time.\n                    if (!this.tRex.jumping && !this.tRex.ducking) {\n                        this.playSound(this.soundFx.BUTTON_PRESS);\n                        this.tRex.startJump(this.currentSpeed);\n                    }\n                }\n                if (this.crashed && e.type == Runner1.events.TOUCHSTART && e.currentTarget == this.containerEl) this.restart();\n            }\n            if (this.playing && !this.crashed && Runner1.keycodes.DUCK[e.keyCode]) {\n                e.preventDefault();\n                if (this.tRex.jumping) // Speed drop, activated only when jump key is not pressed.\n                this.tRex.setSpeedDrop();\n                else if (!this.tRex.jumping && !this.tRex.ducking) // Duck.\n                this.tRex.setDuck(true);\n            }\n        },\n        /**\n         * Process key up.\n         * @param {Event} e\n         */ onKeyUp: function(e) {\n            var keyCode = String(e.keyCode);\n            var isjumpKey = Runner1.keycodes.JUMP[keyCode] || e.type == Runner1.events.TOUCHEND || e.type == Runner1.events.MOUSEDOWN;\n            if (this.isRunning() && isjumpKey) this.tRex.endJump();\n            else if (Runner1.keycodes.DUCK[keyCode]) {\n                this.tRex.speedDrop = false;\n                this.tRex.setDuck(false);\n            } else if (this.crashed) {\n                // Check that enough time has elapsed before allowing jump key to restart.\n                var deltaTime = getTimeStamp() - this.time;\n                if (e.type == Runner1.events.MOUSEUP || Runner1.keycodes.RESTART[keyCode] || this.isLeftClickOnCanvas(e) || deltaTime >= this.config.GAMEOVER_CLEAR_TIME && Runner1.keycodes.JUMP[keyCode]) this.restart();\n            } else if (this.paused && isjumpKey) {\n                // Reset the jump state\n                this.tRex.reset();\n                this.play();\n            }\n        },\n        /**\n         * Returns whether the event was a left click on canvas.\n         * On Windows right click is registered as a click.\n         * @param {Event} e\n         * @return {boolean}\n         */ isLeftClickOnCanvas: function(e) {\n            return e.button != null && e.button < 2 && e.type == Runner1.events.MOUSEUP && e.target == this.canvas;\n        },\n        /**\n         * RequestAnimationFrame wrapper.\n         */ scheduleNextUpdate: function() {\n            if (!this.updatePending) {\n                this.updatePending = true;\n                this.raqId = requestAnimationFrame(this.update.bind(this));\n            }\n        },\n        /**\n         * Whether the game is running.\n         * @return {boolean}\n         */ isRunning: function() {\n            return !!this.raqId;\n        },\n        /**\n         * Game over state.\n         */ gameOver: function() {\n            this.playSound(this.soundFx.HIT);\n            vibrate(200);\n            document.querySelector('#gameover').style.visibility = 'visible';\n            this.stop();\n            this.crashed = true;\n            this.distanceMeter.acheivement = false;\n            this.tRex.update(100, Trex.status.CRASHED);\n            // Game over panel.\n            if (!this.gameOverPanel) this.gameOverPanel = new GameOverPanel(this.canvas, this.spriteDef.TEXT_SPRITE, this.spriteDef.RESTART, this.dimensions);\n            else this.gameOverPanel.draw();\n            // Update the high score.\n            if (this.distanceRan > this.highestScore) {\n                this.highestScore = Math.ceil(this.distanceRan);\n                this.distanceMeter.setHighScore(this.highestScore);\n            }\n            // Reset the time clock.\n            this.time = getTimeStamp();\n        },\n        stop: function() {\n            this.playing = false;\n            this.paused = true;\n            cancelAnimationFrame(this.raqId);\n            this.raqId = 0;\n        },\n        play: function() {\n            if (!this.crashed) {\n                this.playing = true;\n                this.paused = false;\n                this.tRex.update(0, Trex.status.RUNNING);\n                this.time = getTimeStamp();\n                this.update();\n            }\n        },\n        restart: function() {\n            document.querySelector('#gameover').style.visibility = 'hidden';\n            if (!this.raqId) {\n                this.playCount++;\n                this.runningTime = 0;\n                this.playing = true;\n                this.crashed = false;\n                this.distanceRan = 0;\n                this.setSpeed(this.config.SPEED);\n                this.time = getTimeStamp();\n                this.containerEl.classList.remove(Runner1.classes.CRASHED);\n                this.clearCanvas();\n                this.distanceMeter.reset(this.highestScore);\n                this.horizon.reset();\n                this.tRex.reset();\n                this.playSound(this.soundFx.BUTTON_PRESS);\n                this.invert(true);\n                this.update();\n            }\n        },\n        /**\n         * Hides offline messaging for a fullscreen game only experience.\n         */ setArcadeMode () {\n            document.body.classList.add(Runner1.classes.ARCADE_MODE);\n            this.setArcadeModeContainerScale();\n        },\n        /**\n         * Sets the scaling for arcade mode.\n         */ setArcadeModeContainerScale () {\n            const windowHeight = window.innerHeight;\n            const scaleHeight = windowHeight / this.dimensions.HEIGHT;\n            const scaleWidth = window.innerWidth / this.dimensions.WIDTH;\n            const scale = Math.max(1, Math.min(scaleHeight, scaleWidth));\n            const scaledCanvasHeight = this.dimensions.HEIGHT * scale;\n            const translateY = windowHeight - scaledCanvasHeight - Runner1.config.ARCADE_MODE_INITIAL_TOP_POSITION;\n            const cssScale = scale;\n            this.containerEl.style.transform = 'scale(' + cssScale + ') translateY(' + translateY / scale + 'px)';\n        },\n        /**\n         * Pause the game if the tab is not in focus.\n         */ onVisibilityChange: function(e) {\n            if (document.hidden || document.webkitHidden || e.type == 'blur' || document.visibilityState != 'visible') this.stop();\n            else if (!this.crashed) {\n                this.tRex.reset();\n                this.play();\n            }\n        },\n        /**\n         * Play a sound.\n         * @param {SoundBuffer} soundBuffer\n         */ playSound: function(soundBuffer) {\n            if (soundBuffer) {\n                var sourceNode = this.audioContext.createBufferSource();\n                sourceNode.buffer = soundBuffer;\n                sourceNode.connect(this.audioContext.destination);\n                sourceNode.start(0);\n            }\n        },\n        /**\n         * Inverts the current page / canvas colors.\n         * @param {boolean} Whether to reset colors.\n         */ invert: function(reset) {\n            if (reset) {\n                document.body.classList.toggle(Runner1.classes.INVERTED, false);\n                this.invertTimer = 0;\n                this.inverted = false;\n            } else this.inverted = document.body.classList.toggle(Runner1.classes.INVERTED, this.invertTrigger);\n        }\n    };\n    /**\n     * Updates the canvas size taking into\n     * account the backing store pixel ratio and\n     * the device pixel ratio.\n     *\n     * See article by Paul Lewis:\n     * http://www.html5rocks.com/en/tutorials/canvas/hidpi/\n     *\n     * @param {HTMLCanvasElement} canvas\n     * @param {number} opt_width\n     * @param {number} opt_height\n     * @return {boolean} Whether the canvas was scaled.\n     */ Runner1.updateCanvasScaling = function(canvas, opt_width, opt_height) {\n        var context = canvas.getContext('2d');\n        // Query the various pixel ratios\n        var devicePixelRatio = Math.floor(window.devicePixelRatio) || 1;\n        var backingStoreRatio = Math.floor(context.webkitBackingStorePixelRatio) || 1;\n        var ratio = devicePixelRatio / backingStoreRatio;\n        // Upscale the canvas if the two ratios don't match\n        if (devicePixelRatio !== backingStoreRatio) {\n            var oldWidth = opt_width || canvas.width;\n            var oldHeight = opt_height || canvas.height;\n            canvas.width = oldWidth * ratio;\n            canvas.height = oldHeight * ratio;\n            canvas.style.width = oldWidth + 'px';\n            canvas.style.height = oldHeight + 'px';\n            // Scale the context to counter the fact that we've manually scaled\n            // our canvas element.\n            context.scale(ratio, ratio);\n            return true;\n        } else if (devicePixelRatio == 1) {\n            // Reset the canvas width / height. Fixes scaling bug when the page is\n            // zoomed and the devicePixelRatio changes accordingly.\n            canvas.style.width = canvas.width + 'px';\n            canvas.style.height = canvas.height + 'px';\n        }\n        return false;\n    };\n    /**\n     * Get random number.\n     * @param {number} min\n     * @param {number} max\n     * @param {number}\n     */ function getRandomNum(min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    /**\n     * Vibrate on mobile devices.\n     * @param {number} duration Duration of the vibration in milliseconds.\n     */ function vibrate(duration) {\n        if (IS_MOBILE && window.navigator.vibrate) window.navigator.vibrate(duration);\n    }\n    /**\n     * Create canvas element.\n     * @param {HTMLElement} container Element to append canvas to.\n     * @param {number} width\n     * @param {number} height\n     * @param {string} opt_classname\n     * @return {HTMLCanvasElement}\n     */ function createCanvas(container, width, height, opt_classname) {\n        var canvas = document.createElement('canvas');\n        canvas.className = opt_classname ? Runner1.classes.CANVAS + ' ' + opt_classname : Runner1.classes.CANVAS;\n        canvas.width = width;\n        canvas.height = height;\n        container.appendChild(canvas);\n        return canvas;\n    }\n    /**\n     * Decodes the base 64 audio to ArrayBuffer used by Web Audio.\n     * @param {string} base64String\n     */ function decodeBase64ToArrayBuffer(base64String) {\n        var len = base64String.length / 4 * 3;\n        var str = atob(base64String);\n        var arrayBuffer = new ArrayBuffer(len);\n        var bytes = new Uint8Array(arrayBuffer);\n        for(var i = 0; i < len; i++)bytes[i] = str.charCodeAt(i);\n        return bytes.buffer;\n    }\n    /**\n     * Return the current timestamp.\n     * @return {number}\n     */ function getTimeStamp() {\n        return IS_IOS ? new Date().getTime() : performance.now();\n    }\n    //******************************************************************************\n    /**\n     * Game over panel.\n     * @param {!HTMLCanvasElement} canvas\n     * @param {Object} textImgPos\n     * @param {Object} restartImgPos\n     * @param {!Object} dimensions Canvas dimensions.\n     * @constructor\n     */ function GameOverPanel(canvas, textImgPos, restartImgPos, dimensions) {\n        this.canvas = canvas;\n        this.canvasCtx = canvas.getContext('2d');\n        this.canvasDimensions = dimensions;\n        this.textImgPos = textImgPos;\n        this.restartImgPos = restartImgPos;\n        this.draw();\n    }\n    /**\n     * Dimensions used in the panel.\n     * @enum {number}\n     */ GameOverPanel.dimensions = {\n        TEXT_X: 0,\n        TEXT_Y: 13,\n        TEXT_WIDTH: 191,\n        TEXT_HEIGHT: 11,\n        RESTART_WIDTH: 36,\n        RESTART_HEIGHT: 32\n    };\n    GameOverPanel.prototype = {\n        /**\n         * Update the panel dimensions.\n         * @param {number} width New canvas width.\n         * @param {number} opt_height Optional new canvas height.\n         */ updateDimensions: function(width, opt_height) {\n            this.canvasDimensions.WIDTH = width;\n            if (opt_height) this.canvasDimensions.HEIGHT = opt_height;\n        },\n        /**\n         * Draw the panel.\n         */ draw: function() {\n            var dimensions = GameOverPanel.dimensions;\n            var centerX = this.canvasDimensions.WIDTH / 2;\n            // Game over text.\n            var textSourceX = dimensions.TEXT_X;\n            var textSourceY = dimensions.TEXT_Y;\n            var textSourceWidth = dimensions.TEXT_WIDTH;\n            var textSourceHeight = dimensions.TEXT_HEIGHT;\n            var textTargetX = Math.round(centerX - dimensions.TEXT_WIDTH / 2);\n            var textTargetY = Math.round((this.canvasDimensions.HEIGHT - 25) / 3);\n            var textTargetWidth = dimensions.TEXT_WIDTH;\n            var textTargetHeight = dimensions.TEXT_HEIGHT;\n            var restartSourceWidth = dimensions.RESTART_WIDTH;\n            var restartSourceHeight = dimensions.RESTART_HEIGHT;\n            var restartTargetX = centerX - dimensions.RESTART_WIDTH / 2;\n            var restartTargetY = this.canvasDimensions.HEIGHT / 2;\n            if (IS_HIDPI) {\n                textSourceY *= 2;\n                textSourceX *= 2;\n                textSourceWidth *= 2;\n                textSourceHeight *= 2;\n                restartSourceWidth *= 2;\n                restartSourceHeight *= 2;\n            }\n            textSourceX += this.textImgPos.x;\n            textSourceY += this.textImgPos.y;\n            // Game over text from sprite.\n            this.canvasCtx.drawImage(Runner1.imageSprite, textSourceX, textSourceY, textSourceWidth, textSourceHeight, textTargetX, textTargetY, textTargetWidth, textTargetHeight);\n            // Restart button.\n            this.canvasCtx.drawImage(Runner1.imageSprite, this.restartImgPos.x, this.restartImgPos.y, restartSourceWidth, restartSourceHeight, restartTargetX, restartTargetY, dimensions.RESTART_WIDTH, dimensions.RESTART_HEIGHT);\n        }\n    };\n    //******************************************************************************\n    /**\n     * Check for a collision.\n     * @param {!Obstacle} obstacle\n     * @param {!Trex} tRex T-rex object.\n     * @param {HTMLCanvasContext} opt_canvasCtx Optional canvas context for drawing\n     *    collision boxes.\n     * @return {Array<CollisionBox>}\n     */ function checkForCollision(obstacle, tRex, opt_canvasCtx) {\n        var obstacleBoxXPos = Runner1.defaultDimensions.WIDTH + obstacle.xPos;\n        // Adjustments are made to the bounding box as there is a 1 pixel white\n        // border around the t-rex and obstacles.\n        var tRexBox = new CollisionBox(tRex.xPos + 1, tRex.yPos + 1, tRex.config.WIDTH - 2, tRex.config.HEIGHT - 2);\n        var obstacleBox = new CollisionBox(obstacle.xPos + 1, obstacle.yPos + 1, obstacle.typeConfig.width * obstacle.size - 2, obstacle.typeConfig.height - 2);\n        // Debug outer box\n        if (opt_canvasCtx) drawCollisionBoxes(opt_canvasCtx, tRexBox, obstacleBox);\n        // Simple outer bounds check.\n        if (boxCompare(tRexBox, obstacleBox)) {\n            var collisionBoxes = obstacle.collisionBoxes;\n            var tRexCollisionBoxes = tRex.ducking ? Trex.collisionBoxes.DUCKING : Trex.collisionBoxes.RUNNING;\n            // Detailed axis aligned box check.\n            for(var t = 0; t < tRexCollisionBoxes.length; t++)for(var i = 0; i < collisionBoxes.length; i++){\n                // Adjust the box to actual positions.\n                var adjTrexBox = createAdjustedCollisionBox(tRexCollisionBoxes[t], tRexBox);\n                var adjObstacleBox = createAdjustedCollisionBox(collisionBoxes[i], obstacleBox);\n                var crashed = boxCompare(adjTrexBox, adjObstacleBox);\n                // Draw boxes for debug.\n                if (opt_canvasCtx) drawCollisionBoxes(opt_canvasCtx, adjTrexBox, adjObstacleBox);\n                if (crashed) return [\n                    adjTrexBox,\n                    adjObstacleBox\n                ];\n            }\n        }\n        return false;\n    }\n    /**\n     * Adjust the collision box.\n     * @param {!CollisionBox} box The original box.\n     * @param {!CollisionBox} adjustment Adjustment box.\n     * @return {CollisionBox} The adjusted collision box object.\n     */ function createAdjustedCollisionBox(box, adjustment) {\n        return new CollisionBox(box.x + adjustment.x, box.y + adjustment.y, box.width, box.height);\n    }\n    /**\n     * Draw the collision boxes for debug.\n     */ function drawCollisionBoxes(canvasCtx, tRexBox, obstacleBox) {\n        canvasCtx.save();\n        canvasCtx.strokeStyle = '#f00';\n        canvasCtx.strokeRect(tRexBox.x, tRexBox.y, tRexBox.width, tRexBox.height);\n        canvasCtx.strokeStyle = '#0f0';\n        canvasCtx.strokeRect(obstacleBox.x, obstacleBox.y, obstacleBox.width, obstacleBox.height);\n        canvasCtx.restore();\n    }\n    /**\n     * Compare two collision boxes for a collision.\n     * @param {CollisionBox} tRexBox\n     * @param {CollisionBox} obstacleBox\n     * @return {boolean} Whether the boxes intersected.\n     */ function boxCompare(tRexBox, obstacleBox) {\n        var crashed = false;\n        var tRexBoxX = tRexBox.x;\n        var tRexBoxY = tRexBox.y;\n        var obstacleBoxX = obstacleBox.x;\n        var obstacleBoxY = obstacleBox.y;\n        // Axis-Aligned Bounding Box method.\n        if (tRexBox.x < obstacleBoxX + obstacleBox.width && tRexBox.x + tRexBox.width > obstacleBoxX && tRexBox.y < obstacleBox.y + obstacleBox.height && tRexBox.height + tRexBox.y > obstacleBox.y) crashed = true;\n        return crashed;\n    }\n    //******************************************************************************\n    /**\n     * Collision box object.\n     * @param {number} x X position.\n     * @param {number} y Y Position.\n     * @param {number} w Width.\n     * @param {number} h Height.\n     */ function CollisionBox(x, y, w, h) {\n        this.x = x;\n        this.y = y;\n        this.width = w;\n        this.height = h;\n    }\n    //******************************************************************************\n    /**\n     * Obstacle.\n     * @param {HTMLCanvasCtx} canvasCtx\n     * @param {Obstacle.type} type\n     * @param {Object} spritePos Obstacle position in sprite.\n     * @param {Object} dimensions\n     * @param {number} gapCoefficient Mutipler in determining the gap.\n     * @param {number} speed\n     * @param {number} opt_xOffset\n     */ function Obstacle(canvasCtx, type, spriteImgPos, dimensions, gapCoefficient, speed, opt_xOffset) {\n        this.canvasCtx = canvasCtx;\n        this.spritePos = spriteImgPos;\n        this.typeConfig = type;\n        this.gapCoefficient = gapCoefficient;\n        this.size = getRandomNum(1, Obstacle.MAX_OBSTACLE_LENGTH);\n        this.dimensions = dimensions;\n        this.remove = false;\n        this.xPos = dimensions.WIDTH + (opt_xOffset || 0);\n        this.yPos = 0;\n        this.width = 0;\n        this.collisionBoxes = [];\n        this.gap = 0;\n        this.speedOffset = 0;\n        // For animated obstacles.\n        this.currentFrame = 0;\n        this.timer = 0;\n        this.init(speed);\n    }\n    /**\n     * Coefficient for calculating the maximum gap.\n     * @const\n     */ Obstacle.MAX_GAP_COEFFICIENT = 1.5;\n    /**\n     * Maximum obstacle grouping count.\n     * @const\n     */ Obstacle.MAX_OBSTACLE_LENGTH = 3, Obstacle.prototype = {\n        /**\n             * Initialise the DOM for the obstacle.\n             * @param {number} speed\n             */ init: function(speed) {\n            this.cloneCollisionBoxes();\n            // Only allow sizing if we're at the right speed.\n            if (this.size > 1 && this.typeConfig.multipleSpeed > speed) this.size = 1;\n            this.width = this.typeConfig.width * this.size;\n            // Check if obstacle can be positioned at various heights.\n            if (Array.isArray(this.typeConfig.yPos)) {\n                var yPosConfig = IS_MOBILE ? this.typeConfig.yPosMobile : this.typeConfig.yPos;\n                this.yPos = yPosConfig[getRandomNum(0, yPosConfig.length - 1)];\n            } else this.yPos = this.typeConfig.yPos;\n            this.draw();\n            // Make collision box adjustments,\n            // Central box is adjusted to the size as one box.\n            //      ____        ______        ________\n            //    _|   |-|    _|     |-|    _|       |-|\n            //   | |<->| |   | |<--->| |   | |<----->| |\n            //   | | 1 | |   | |  2  | |   | |   3   | |\n            //   |_|___|_|   |_|_____|_|   |_|_______|_|\n            //\n            if (this.size > 1) {\n                this.collisionBoxes[1].width = this.width - this.collisionBoxes[0].width - this.collisionBoxes[2].width;\n                this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width;\n            }\n            // For obstacles that go at a different speed from the horizon.\n            if (this.typeConfig.speedOffset) this.speedOffset = Math.random() > 0.5 ? this.typeConfig.speedOffset : -this.typeConfig.speedOffset;\n            this.gap = this.getGap(this.gapCoefficient, speed);\n        },\n        /**\n             * Draw and crop based on size.\n             */ draw: function() {\n            var sourceWidth = this.typeConfig.width;\n            var sourceHeight = this.typeConfig.height;\n            if (IS_HIDPI) {\n                sourceWidth = sourceWidth * 2;\n                sourceHeight = sourceHeight * 2;\n            }\n            // X position in sprite.\n            var sourceX = sourceWidth * this.size * (0.5 * (this.size - 1)) + this.spritePos.x;\n            // Animation frames.\n            if (this.currentFrame > 0) sourceX += sourceWidth * this.currentFrame;\n            this.canvasCtx.drawImage(Runner1.imageSprite, sourceX, this.spritePos.y, sourceWidth * this.size, sourceHeight, this.xPos, this.yPos, this.typeConfig.width * this.size, this.typeConfig.height);\n        },\n        /**\n             * Obstacle frame update.\n             * @param {number} deltaTime\n             * @param {number} speed\n             */ update: function(deltaTime, speed) {\n            if (!this.remove) {\n                if (this.typeConfig.speedOffset) speed += this.speedOffset;\n                this.xPos -= Math.floor(speed * FPS / 1000 * deltaTime);\n                // Update frame\n                if (this.typeConfig.numFrames) {\n                    this.timer += deltaTime;\n                    if (this.timer >= this.typeConfig.frameRate) {\n                        this.currentFrame = this.currentFrame == this.typeConfig.numFrames - 1 ? 0 : this.currentFrame + 1;\n                        this.timer = 0;\n                    }\n                }\n                this.draw();\n                if (!this.isVisible()) this.remove = true;\n            }\n        },\n        /**\n             * Calculate a random gap size.\n             * - Minimum gap gets wider as speed increses\n             * @param {number} gapCoefficient\n             * @param {number} speed\n             * @return {number} The gap size.\n             */ getGap: function(gapCoefficient, speed) {\n            var minGap = Math.round(this.width * speed + this.typeConfig.minGap * gapCoefficient);\n            var maxGap = Math.round(minGap * Obstacle.MAX_GAP_COEFFICIENT);\n            return getRandomNum(minGap, maxGap);\n        },\n        /**\n             * Check if obstacle is visible.\n             * @return {boolean} Whether the obstacle is in the game area.\n             */ isVisible: function() {\n            return this.xPos + this.width > 0;\n        },\n        /**\n             * Make a copy of the collision boxes, since these will change based on\n             * obstacle type and size.\n             */ cloneCollisionBoxes: function() {\n            var collisionBoxes = this.typeConfig.collisionBoxes;\n            for(var i = collisionBoxes.length - 1; i >= 0; i--)this.collisionBoxes[i] = new CollisionBox(collisionBoxes[i].x, collisionBoxes[i].y, collisionBoxes[i].width, collisionBoxes[i].height);\n        }\n    };\n    /**\n     * Obstacle definitions.\n     * minGap: minimum pixel space betweeen obstacles.\n     * multipleSpeed: Speed at which multiples are allowed.\n     * speedOffset: speed faster / slower than the horizon.\n     * minSpeed: Minimum speed which the obstacle can make an appearance.\n     */ Obstacle.types = [\n        {\n            type: 'CACTUS_SMALL',\n            width: 17,\n            height: 35,\n            yPos: 105,\n            multipleSpeed: 4,\n            minGap: 120,\n            minSpeed: 0,\n            collisionBoxes: [\n                new CollisionBox(0, 7, 5, 27),\n                new CollisionBox(4, 0, 6, 34),\n                new CollisionBox(10, 4, 7, 14)\n            ]\n        },\n        {\n            type: 'CACTUS_LARGE',\n            width: 25,\n            height: 50,\n            yPos: 90,\n            multipleSpeed: 7,\n            minGap: 120,\n            minSpeed: 0,\n            collisionBoxes: [\n                new CollisionBox(0, 12, 7, 38),\n                new CollisionBox(8, 0, 7, 49),\n                new CollisionBox(13, 10, 10, 38)\n            ]\n        },\n        {\n            type: 'PTERODACTYL',\n            width: 46,\n            height: 40,\n            yPos: [\n                100,\n                75,\n                50\n            ],\n            yPosMobile: [\n                100,\n                50\n            ],\n            multipleSpeed: 999,\n            minSpeed: 8.5,\n            minGap: 150,\n            collisionBoxes: [\n                new CollisionBox(15, 15, 16, 5),\n                new CollisionBox(18, 21, 24, 6),\n                new CollisionBox(2, 14, 4, 3),\n                new CollisionBox(6, 10, 4, 7),\n                new CollisionBox(10, 8, 6, 9)\n            ],\n            numFrames: 2,\n            frameRate: 1000 / 6,\n            speedOffset: .8\n        }\n    ];\n    //******************************************************************************\n    /**\n     * T-rex game character.\n     * @param {HTMLCanvas} canvas\n     * @param {Object} spritePos Positioning within image sprite.\n     * @constructor\n     */ function Trex(canvas, spritePos) {\n        this.canvas = canvas;\n        this.canvasCtx = canvas.getContext('2d');\n        this.spritePos = spritePos;\n        this.xPos = 0;\n        this.yPos = 0;\n        // Position when on the ground.\n        this.groundYPos = 0;\n        this.currentFrame = 0;\n        this.currentAnimFrames = [];\n        this.blinkDelay = 0;\n        this.blinkCount = 0;\n        this.animStartTime = 0;\n        this.timer = 0;\n        this.msPerFrame = 1000 / FPS;\n        this.config = Trex.config;\n        // Current status.\n        this.status = Trex.status.WAITING;\n        this.jumping = false;\n        this.ducking = false;\n        this.jumpVelocity = 0;\n        this.reachedMinHeight = false;\n        this.speedDrop = false;\n        this.jumpCount = 0;\n        this.jumpspotX = 0;\n        this.init();\n    }\n    /**\n     * T-rex player config.\n     * @enum {number}\n     */ Trex.config = {\n        DROP_VELOCITY: -5,\n        GRAVITY: 0.6,\n        HEIGHT: 47,\n        HEIGHT_DUCK: 25,\n        INIITAL_JUMP_VELOCITY: -10,\n        INTRO_DURATION: 1500,\n        MAX_JUMP_HEIGHT: 30,\n        MIN_JUMP_HEIGHT: 30,\n        SPEED_DROP_COEFFICIENT: 3,\n        SPRITE_WIDTH: 262,\n        START_X_POS: 50,\n        WIDTH: 44,\n        WIDTH_DUCK: 59\n    };\n    /**\n     * Used in collision detection.\n     * @type {Array<CollisionBox>}\n     */ Trex.collisionBoxes = {\n        DUCKING: [\n            new CollisionBox(1, 18, 55, 25)\n        ],\n        RUNNING: [\n            new CollisionBox(22, 0, 17, 16),\n            new CollisionBox(1, 18, 30, 9),\n            new CollisionBox(10, 35, 14, 8),\n            new CollisionBox(1, 24, 29, 5),\n            new CollisionBox(5, 30, 21, 4),\n            new CollisionBox(9, 34, 15, 4)\n        ]\n    };\n    /**\n     * Animation states.\n     * @enum {string}\n     */ Trex.status = {\n        CRASHED: 'CRASHED',\n        DUCKING: 'DUCKING',\n        JUMPING: 'JUMPING',\n        RUNNING: 'RUNNING',\n        WAITING: 'WAITING'\n    };\n    /**\n     * Blinking coefficient.\n     * @const\n     */ Trex.BLINK_TIMING = 7000;\n    /**\n     * Animation config for different states.\n     * @enum {Object}\n     */ Trex.animFrames = {\n        WAITING: {\n            frames: [\n                44,\n                0\n            ],\n            msPerFrame: 1000 / 3\n        },\n        RUNNING: {\n            frames: [\n                88,\n                132\n            ],\n            msPerFrame: 1000 / 12\n        },\n        CRASHED: {\n            frames: [\n                220\n            ],\n            msPerFrame: 1000 / 60\n        },\n        JUMPING: {\n            frames: [\n                0\n            ],\n            msPerFrame: 1000 / 60\n        },\n        DUCKING: {\n            frames: [\n                264,\n                323\n            ],\n            msPerFrame: 125\n        }\n    };\n    Trex.prototype = {\n        /**\n         * T-rex player initaliser.\n         * Sets the t-rex to blink at random intervals.\n         */ init: function() {\n            this.groundYPos = Runner1.defaultDimensions.HEIGHT - this.config.HEIGHT - Runner1.config.BOTTOM_PAD;\n            this.yPos = this.groundYPos;\n            this.minJumpHeight = this.groundYPos - this.config.MIN_JUMP_HEIGHT;\n            this.draw(0, 0);\n            this.update(0, Trex.status.WAITING);\n        },\n        /**\n         * Setter for the jump velocity.\n         * The approriate drop velocity is also set.\n         */ setJumpVelocity: function(setting) {\n            this.config.INIITAL_JUMP_VELOCITY = -setting;\n            this.config.DROP_VELOCITY = -setting / 2;\n        },\n        /**\n         * Set the animation status.\n         * @param {!number} deltaTime\n         * @param {Trex.status} status Optional status to switch to.\n         */ update: function(deltaTime, opt_status) {\n            this.timer += deltaTime;\n            // Update the status.\n            if (opt_status) {\n                this.status = opt_status;\n                this.currentFrame = 0;\n                this.msPerFrame = Trex.animFrames[opt_status].msPerFrame;\n                this.currentAnimFrames = Trex.animFrames[opt_status].frames;\n                if (opt_status == Trex.status.WAITING) {\n                    this.animStartTime = getTimeStamp();\n                    this.setBlinkDelay();\n                }\n            }\n            // Game intro animation, T-rex moves in from the left.\n            if (this.playingIntro && this.xPos < this.config.START_X_POS) this.xPos += Math.round(this.config.START_X_POS / this.config.INTRO_DURATION * deltaTime);\n            if (this.status == Trex.status.WAITING) this.blink(getTimeStamp());\n            else this.draw(this.currentAnimFrames[this.currentFrame], 0);\n            // Update the frame position.\n            if (this.timer >= this.msPerFrame) {\n                this.currentFrame = this.currentFrame == this.currentAnimFrames.length - 1 ? 0 : this.currentFrame + 1;\n                this.timer = 0;\n            }\n            // Speed drop becomes duck if the down key is still being pressed.\n            if (this.speedDrop && this.yPos == this.groundYPos) {\n                this.speedDrop = false;\n                this.setDuck(true);\n            }\n        },\n        /**\n         * Draw the t-rex to a particular position.\n         * @param {number} x\n         * @param {number} y\n         */ draw: function(x, y) {\n            var sourceX = x;\n            var sourceY = y;\n            var sourceWidth = this.ducking && this.status != Trex.status.CRASHED ? this.config.WIDTH_DUCK : this.config.WIDTH;\n            var sourceHeight = this.config.HEIGHT;\n            if (IS_HIDPI) {\n                sourceX *= 2;\n                sourceY *= 2;\n                sourceWidth *= 2;\n                sourceHeight *= 2;\n            }\n            // Adjustments for sprite sheet position.\n            sourceX += this.spritePos.x;\n            sourceY += this.spritePos.y;\n            // Ducking.\n            if (this.ducking && this.status != Trex.status.CRASHED) this.canvasCtx.drawImage(Runner1.imageSprite, sourceX, sourceY, sourceWidth, sourceHeight, this.xPos, this.yPos, this.config.WIDTH_DUCK, this.config.HEIGHT);\n            else {\n                // Crashed whilst ducking. Trex is standing up so needs adjustment.\n                if (this.ducking && this.status == Trex.status.CRASHED) this.xPos++;\n                // Standing / running\n                this.canvasCtx.drawImage(Runner1.imageSprite, sourceX, sourceY, sourceWidth, sourceHeight, this.xPos, this.yPos, this.config.WIDTH, this.config.HEIGHT);\n            }\n        },\n        /**\n         * Sets a random time for the blink to happen.\n         */ setBlinkDelay: function() {\n            this.blinkDelay = Math.ceil(Math.random() * Trex.BLINK_TIMING);\n        },\n        /**\n         * Make t-rex blink at random intervals.\n         * @param {number} time Current time in milliseconds.\n         */ blink: function(time) {\n            var deltaTime = time - this.animStartTime;\n            if (deltaTime >= this.blinkDelay) {\n                this.draw(this.currentAnimFrames[this.currentFrame], 0);\n                if (this.currentFrame == 1) {\n                    // Set new random delay to blink.\n                    this.setBlinkDelay();\n                    this.animStartTime = time;\n                    this.blinkCount++;\n                }\n            }\n        },\n        /**\n         * Initialise a jump.\n         * @param {number} speed\n         */ startJump: function(speed) {\n            if (!this.jumping) {\n                this.update(0, Trex.status.JUMPING);\n                // Tweak the jump velocity based on the speed.\n                this.jumpVelocity = this.config.INIITAL_JUMP_VELOCITY - speed / 10;\n                this.jumping = true;\n                this.reachedMinHeight = false;\n                this.speedDrop = false;\n            }\n        },\n        /**\n         * Jump is complete, falling down.\n         */ endJump: function() {\n            if (this.reachedMinHeight && this.jumpVelocity < this.config.DROP_VELOCITY) this.jumpVelocity = this.config.DROP_VELOCITY;\n        },\n        /**\n         * Update frame for a jump.\n         * @param {number} deltaTime\n         * @param {number} speed\n         */ updateJump: function(deltaTime, speed) {\n            var msPerFrame = Trex.animFrames[this.status].msPerFrame;\n            var framesElapsed = deltaTime / msPerFrame;\n            // Speed drop makes Trex fall faster.\n            if (this.speedDrop) this.yPos += Math.round(this.jumpVelocity * this.config.SPEED_DROP_COEFFICIENT * framesElapsed);\n            else this.yPos += Math.round(this.jumpVelocity * framesElapsed);\n            this.jumpVelocity += this.config.GRAVITY * framesElapsed;\n            // Minimum height has been reached.\n            if (this.yPos < this.minJumpHeight || this.speedDrop) this.reachedMinHeight = true;\n            // Reached max height\n            if (this.yPos < this.config.MAX_JUMP_HEIGHT || this.speedDrop) this.endJump();\n            // Back down at ground level. Jump completed.\n            if (this.yPos > this.groundYPos) {\n                this.reset();\n                this.jumpCount++;\n            }\n            this.update(deltaTime);\n        },\n        /**\n         * Set the speed drop. Immediately cancels the current jump.\n         */ setSpeedDrop: function() {\n            this.speedDrop = true;\n            this.jumpVelocity = 1;\n        },\n        /**\n         * @param {boolean} isDucking.\n         */ setDuck: function(isDucking) {\n            if (isDucking && this.status != Trex.status.DUCKING) {\n                this.update(0, Trex.status.DUCKING);\n                this.ducking = true;\n            } else if (this.status == Trex.status.DUCKING) {\n                this.update(0, Trex.status.RUNNING);\n                this.ducking = false;\n            }\n        },\n        /**\n         * Reset the t-rex to running at start of game.\n         */ reset: function() {\n            this.yPos = this.groundYPos;\n            this.jumpVelocity = 0;\n            this.jumping = false;\n            this.ducking = false;\n            this.update(0, Trex.status.RUNNING);\n            this.midair = false;\n            this.speedDrop = false;\n            this.jumpCount = 0;\n        }\n    };\n    //******************************************************************************\n    /**\n     * Handles displaying the distance meter.\n     * @param {!HTMLCanvasElement} canvas\n     * @param {Object} spritePos Image position in sprite.\n     * @param {number} canvasWidth\n     * @constructor\n     */ function DistanceMeter(canvas, spritePos, canvasWidth) {\n        this.canvas = canvas;\n        this.canvasCtx = canvas.getContext('2d');\n        this.image = Runner1.imageSprite;\n        this.spritePos = spritePos;\n        this.x = 0;\n        this.y = 5;\n        this.currentDistance = 0;\n        this.maxScore = 0;\n        this.highScore = 0;\n        this.container = null;\n        this.digits = [];\n        this.acheivement = false;\n        this.defaultString = '';\n        this.flashTimer = 0;\n        this.flashIterations = 0;\n        this.invertTrigger = false;\n        this.config = DistanceMeter.config;\n        this.maxScoreUnits = this.config.MAX_DISTANCE_UNITS;\n        this.init(canvasWidth);\n    }\n    /**\n     * @enum {number}\n     */ DistanceMeter.dimensions = {\n        WIDTH: 10,\n        HEIGHT: 13,\n        DEST_WIDTH: 11\n    };\n    /**\n     * Y positioning of the digits in the sprite sheet.\n     * X position is always 0.\n     * @type {Array<number>}\n     */ DistanceMeter.yPos = [\n        0,\n        13,\n        27,\n        40,\n        53,\n        67,\n        80,\n        93,\n        107,\n        120\n    ];\n    /**\n     * Distance meter config.\n     * @enum {number}\n     */ DistanceMeter.config = {\n        // Number of digits.\n        MAX_DISTANCE_UNITS: 5,\n        // Distance that causes achievement animation.\n        ACHIEVEMENT_DISTANCE: 100,\n        // Used for conversion from pixel distance to a scaled unit.\n        COEFFICIENT: 0.025,\n        // Flash duration in milliseconds.\n        FLASH_DURATION: 250,\n        // Flash iterations for achievement animation.\n        FLASH_ITERATIONS: 3\n    };\n    DistanceMeter.prototype = {\n        /**\n         * Initialise the distance meter to '00000'.\n         * @param {number} width Canvas width in px.\n         */ init: function(width) {\n            var maxDistanceStr = '';\n            this.calcXPos(width);\n            this.maxScore = this.maxScoreUnits;\n            for(var i = 0; i < this.maxScoreUnits; i++){\n                this.draw(i, 0);\n                this.defaultString += '0';\n                maxDistanceStr += '9';\n            }\n            this.maxScore = parseInt(maxDistanceStr);\n        },\n        /**\n         * Calculate the xPos in the canvas.\n         * @param {number} canvasWidth\n         */ calcXPos: function(canvasWidth) {\n            this.x = canvasWidth - DistanceMeter.dimensions.DEST_WIDTH * (this.maxScoreUnits + 1);\n        },\n        /**\n         * Draw a digit to canvas.\n         * @param {number} digitPos Position of the digit.\n         * @param {number} value Digit value 0-9.\n         * @param {boolean} opt_highScore Whether drawing the high score.\n         */ draw: function(digitPos, value, opt_highScore) {\n            var sourceWidth = DistanceMeter.dimensions.WIDTH;\n            var sourceHeight = DistanceMeter.dimensions.HEIGHT;\n            var sourceX = DistanceMeter.dimensions.WIDTH * value;\n            var sourceY = 0;\n            var targetX = digitPos * DistanceMeter.dimensions.DEST_WIDTH;\n            var targetY = this.y;\n            var targetWidth = DistanceMeter.dimensions.WIDTH;\n            var targetHeight = DistanceMeter.dimensions.HEIGHT;\n            // For high DPI we 2x source values.\n            if (IS_HIDPI) {\n                sourceWidth *= 2;\n                sourceHeight *= 2;\n                sourceX *= 2;\n            }\n            sourceX += this.spritePos.x;\n            sourceY += this.spritePos.y;\n            this.canvasCtx.save();\n            if (opt_highScore) {\n                // Left of the current score.\n                var highScoreX = this.x - this.maxScoreUnits * 2 * DistanceMeter.dimensions.WIDTH;\n                this.canvasCtx.translate(highScoreX, this.y);\n            } else this.canvasCtx.translate(this.x, this.y);\n            this.canvasCtx.drawImage(this.image, sourceX, sourceY, sourceWidth, sourceHeight, targetX, targetY, targetWidth, targetHeight);\n            this.canvasCtx.restore();\n        },\n        /**\n         * Covert pixel distance to a 'real' distance.\n         * @param {number} distance Pixel distance ran.\n         * @return {number} The 'real' distance ran.\n         */ getActualDistance: function(distance) {\n            return distance ? Math.round(distance * this.config.COEFFICIENT) : 0;\n        },\n        /**\n         * Update the distance meter.\n         * @param {number} distance\n         * @param {number} deltaTime\n         * @return {boolean} Whether the acheivement sound fx should be played.\n         */ update: function(deltaTime, distance) {\n            var paint = true;\n            var playSound = false;\n            if (!this.acheivement) {\n                distance = this.getActualDistance(distance);\n                // Score has gone beyond the initial digit count.\n                if (distance > this.maxScore && this.maxScoreUnits == this.config.MAX_DISTANCE_UNITS) {\n                    this.maxScoreUnits++;\n                    this.maxScore = parseInt(this.maxScore + '9');\n                } else this.distance = 0;\n                if (distance > 0) {\n                    // Acheivement unlocked\n                    if (distance % this.config.ACHIEVEMENT_DISTANCE == 0) {\n                        // Flash score and play sound.\n                        this.acheivement = true;\n                        this.flashTimer = 0;\n                        playSound = true;\n                    }\n                    // Create a string representation of the distance with leading 0.\n                    var distanceStr = (this.defaultString + distance).substr(-this.maxScoreUnits);\n                    this.digits = distanceStr.split('');\n                } else this.digits = this.defaultString.split('');\n            } else // Control flashing of the score on reaching acheivement.\n            if (this.flashIterations <= this.config.FLASH_ITERATIONS) {\n                this.flashTimer += deltaTime;\n                if (this.flashTimer < this.config.FLASH_DURATION) paint = false;\n                else if (this.flashTimer > this.config.FLASH_DURATION * 2) {\n                    this.flashTimer = 0;\n                    this.flashIterations++;\n                }\n            } else {\n                this.acheivement = false;\n                this.flashIterations = 0;\n                this.flashTimer = 0;\n            }\n            // Draw the digits if not flashing.\n            if (paint) for(var i = this.digits.length - 1; i >= 0; i--)this.draw(i, parseInt(this.digits[i]));\n            this.drawHighScore();\n            return playSound;\n        },\n        /**\n         * Draw the high score.\n         */ drawHighScore: function() {\n            this.canvasCtx.save();\n            this.canvasCtx.globalAlpha = .8;\n            for(var i = this.highScore.length - 1; i >= 0; i--)this.draw(i, parseInt(this.highScore[i], 10), true);\n            this.canvasCtx.restore();\n        },\n        /**\n         * Set the highscore as a array string.\n         * Position of char in the sprite: H - 10, I - 11.\n         * @param {number} distance Distance ran in pixels.\n         */ setHighScore: function(distance) {\n            distance = this.getActualDistance(distance);\n            var highScoreStr = (this.defaultString + distance).substr(-this.maxScoreUnits);\n            this.highScore = [\n                '10',\n                '11',\n                ''\n            ].concat(highScoreStr.split(''));\n        },\n        /**\n         * Reset the distance meter back to '00000'.\n         */ reset: function() {\n            this.update(0);\n            this.acheivement = false;\n        }\n    };\n    //******************************************************************************\n    /**\n     * Cloud background item.\n     * Similar to an obstacle object but without collision boxes.\n     * @param {HTMLCanvasElement} canvas Canvas element.\n     * @param {Object} spritePos Position of image in sprite.\n     * @param {number} containerWidth\n     */ function Cloud(canvas, spritePos, containerWidth) {\n        this.canvas = canvas;\n        this.canvasCtx = this.canvas.getContext('2d');\n        this.spritePos = spritePos;\n        this.containerWidth = containerWidth;\n        this.xPos = containerWidth;\n        this.yPos = 0;\n        this.remove = false;\n        this.cloudGap = getRandomNum(Cloud.config.MIN_CLOUD_GAP, Cloud.config.MAX_CLOUD_GAP);\n        this.init();\n    }\n    /**\n     * Cloud object config.\n     * @enum {number}\n     */ Cloud.config = {\n        HEIGHT: 14,\n        MAX_CLOUD_GAP: 400,\n        MAX_SKY_LEVEL: 30,\n        MIN_CLOUD_GAP: 100,\n        MIN_SKY_LEVEL: 71,\n        WIDTH: 46\n    };\n    Cloud.prototype = {\n        /**\n         * Initialise the cloud. Sets the Cloud height.\n         */ init: function() {\n            this.yPos = getRandomNum(Cloud.config.MAX_SKY_LEVEL, Cloud.config.MIN_SKY_LEVEL);\n            this.draw();\n        },\n        /**\n         * Draw the cloud.\n         */ draw: function() {\n            this.canvasCtx.save();\n            var sourceWidth = Cloud.config.WIDTH;\n            var sourceHeight = Cloud.config.HEIGHT;\n            if (IS_HIDPI) {\n                sourceWidth = sourceWidth * 2;\n                sourceHeight = sourceHeight * 2;\n            }\n            this.canvasCtx.drawImage(Runner1.imageSprite, this.spritePos.x, this.spritePos.y, sourceWidth, sourceHeight, this.xPos, this.yPos, Cloud.config.WIDTH, Cloud.config.HEIGHT);\n            this.canvasCtx.restore();\n        },\n        /**\n         * Update the cloud position.\n         * @param {number} speed\n         */ update: function(speed) {\n            if (!this.remove) {\n                this.xPos -= Math.ceil(speed);\n                this.draw();\n                // Mark as removeable if no longer in the canvas.\n                if (!this.isVisible()) this.remove = true;\n            }\n        },\n        /**\n         * Check if the cloud is visible on the stage.\n         * @return {boolean}\n         */ isVisible: function() {\n            return this.xPos + Cloud.config.WIDTH > 0;\n        }\n    };\n    //******************************************************************************\n    /**\n     * Nightmode shows a moon and stars on the horizon.\n     */ function NightMode(canvas, spritePos, containerWidth) {\n        this.spritePos = spritePos;\n        this.canvas = canvas;\n        this.canvasCtx = canvas.getContext('2d');\n        this.xPos = containerWidth - 50;\n        this.yPos = 30;\n        this.currentPhase = 0;\n        this.opacity = 0;\n        this.containerWidth = containerWidth;\n        this.stars = [];\n        this.drawStars = false;\n        this.placeStars();\n    }\n    /**\n     * @enum {number}\n     */ NightMode.config = {\n        FADE_SPEED: 0.035,\n        HEIGHT: 40,\n        MOON_SPEED: 0.25,\n        NUM_STARS: 2,\n        STAR_SIZE: 9,\n        STAR_SPEED: 0.3,\n        STAR_MAX_Y: 70,\n        WIDTH: 20\n    };\n    NightMode.phases = [\n        140,\n        120,\n        100,\n        60,\n        40,\n        20,\n        0\n    ];\n    NightMode.prototype = {\n        /**\n         * Update moving moon, changing phases.\n         * @param {boolean} activated Whether night mode is activated.\n         * @param {number} delta\n         */ update: function(activated, delta) {\n            // Moon phase.\n            if (activated && this.opacity == 0) {\n                this.currentPhase++;\n                if (this.currentPhase >= NightMode.phases.length) this.currentPhase = 0;\n            }\n            // Fade in / out.\n            if (activated && (this.opacity < 1 || this.opacity == 0)) this.opacity += NightMode.config.FADE_SPEED;\n            else if (this.opacity > 0) this.opacity -= NightMode.config.FADE_SPEED;\n            // Set moon positioning.\n            if (this.opacity > 0) {\n                this.xPos = this.updateXPos(this.xPos, NightMode.config.MOON_SPEED);\n                // Update stars.\n                if (this.drawStars) for(var i = 0; i < NightMode.config.NUM_STARS; i++)this.stars[i].x = this.updateXPos(this.stars[i].x, NightMode.config.STAR_SPEED);\n                this.draw();\n            } else {\n                this.opacity = 0;\n                this.placeStars();\n            }\n            this.drawStars = true;\n        },\n        updateXPos: function(currentPos, speed) {\n            if (currentPos < -NightMode.config.WIDTH) currentPos = this.containerWidth;\n            else currentPos -= speed;\n            return currentPos;\n        },\n        draw: function() {\n            var moonSourceWidth = this.currentPhase == 3 ? NightMode.config.WIDTH * 2 : NightMode.config.WIDTH;\n            var moonSourceHeight = NightMode.config.HEIGHT;\n            var moonSourceX = this.spritePos.x + NightMode.phases[this.currentPhase];\n            var moonOutputWidth = moonSourceWidth;\n            var starSize = NightMode.config.STAR_SIZE;\n            var starSourceX = Runner1.spriteDefinition.LDPI.STAR.x;\n            if (IS_HIDPI) {\n                moonSourceWidth *= 2;\n                moonSourceHeight *= 2;\n                moonSourceX = this.spritePos.x + NightMode.phases[this.currentPhase] * 2;\n                starSize *= 2;\n                starSourceX = Runner1.spriteDefinition.HDPI.STAR.x;\n            }\n            this.canvasCtx.save();\n            this.canvasCtx.globalAlpha = this.opacity;\n            // Stars.\n            if (this.drawStars) for(var i = 0; i < NightMode.config.NUM_STARS; i++)this.canvasCtx.drawImage(Runner1.imageSprite, starSourceX, this.stars[i].sourceY, starSize, starSize, Math.round(this.stars[i].x), this.stars[i].y, NightMode.config.STAR_SIZE, NightMode.config.STAR_SIZE);\n            // Moon.\n            this.canvasCtx.drawImage(Runner1.imageSprite, moonSourceX, this.spritePos.y, moonSourceWidth, moonSourceHeight, Math.round(this.xPos), this.yPos, moonOutputWidth, NightMode.config.HEIGHT);\n            this.canvasCtx.globalAlpha = 1;\n            this.canvasCtx.restore();\n        },\n        // Do star placement.\n        placeStars: function() {\n            var segmentSize = Math.round(this.containerWidth / NightMode.config.NUM_STARS);\n            for(var i = 0; i < NightMode.config.NUM_STARS; i++){\n                this.stars[i] = {};\n                this.stars[i].x = getRandomNum(segmentSize * i, segmentSize * (i + 1));\n                this.stars[i].y = getRandomNum(0, NightMode.config.STAR_MAX_Y);\n                if (IS_HIDPI) this.stars[i].sourceY = Runner1.spriteDefinition.HDPI.STAR.y + NightMode.config.STAR_SIZE * 2 * i;\n                else this.stars[i].sourceY = Runner1.spriteDefinition.LDPI.STAR.y + NightMode.config.STAR_SIZE * i;\n            }\n        },\n        reset: function() {\n            this.currentPhase = 0;\n            this.opacity = 0;\n            this.update(false);\n        }\n    };\n    //******************************************************************************\n    /**\n     * Horizon Line.\n     * Consists of two connecting lines. Randomly assigns a flat / bumpy horizon.\n     * @param {HTMLCanvasElement} canvas\n     * @param {Object} spritePos Horizon position in sprite.\n     * @constructor\n     */ function HorizonLine(canvas, spritePos) {\n        this.spritePos = spritePos;\n        this.canvas = canvas;\n        this.canvasCtx = canvas.getContext('2d');\n        this.sourceDimensions = {};\n        this.dimensions = HorizonLine.dimensions;\n        this.sourceXPos = [\n            this.spritePos.x,\n            this.spritePos.x + this.dimensions.WIDTH\n        ];\n        this.xPos = [];\n        this.yPos = 0;\n        this.bumpThreshold = 0.5;\n        this.setSourceDimensions();\n        this.draw();\n    }\n    /**\n     * Horizon line dimensions.\n     * @enum {number}\n     */ HorizonLine.dimensions = {\n        WIDTH: 600,\n        HEIGHT: 12,\n        YPOS: 127\n    };\n    HorizonLine.prototype = {\n        /**\n         * Set the source dimensions of the horizon line.\n         */ setSourceDimensions: function() {\n            for(var dimension in HorizonLine.dimensions){\n                if (IS_HIDPI) {\n                    if (dimension != 'YPOS') this.sourceDimensions[dimension] = HorizonLine.dimensions[dimension] * 2;\n                } else this.sourceDimensions[dimension] = HorizonLine.dimensions[dimension];\n                this.dimensions[dimension] = HorizonLine.dimensions[dimension];\n            }\n            this.xPos = [\n                0,\n                HorizonLine.dimensions.WIDTH\n            ];\n            this.yPos = HorizonLine.dimensions.YPOS;\n        },\n        /**\n         * Return the crop x position of a type.\n         */ getRandomType: function() {\n            return Math.random() > this.bumpThreshold ? this.dimensions.WIDTH : 0;\n        },\n        /**\n         * Draw the horizon line.\n         */ draw: function() {\n            this.canvasCtx.drawImage(Runner1.imageSprite, this.sourceXPos[0], this.spritePos.y, this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT, this.xPos[0], this.yPos, this.dimensions.WIDTH, this.dimensions.HEIGHT);\n            this.canvasCtx.drawImage(Runner1.imageSprite, this.sourceXPos[1], this.spritePos.y, this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT, this.xPos[1], this.yPos, this.dimensions.WIDTH, this.dimensions.HEIGHT);\n        },\n        /**\n         * Update the x position of an indivdual piece of the line.\n         * @param {number} pos Line position.\n         * @param {number} increment\n         */ updateXPos: function(pos, increment) {\n            var line1 = pos;\n            var line2 = pos == 0 ? 1 : 0;\n            this.xPos[line1] -= increment;\n            this.xPos[line2] = this.xPos[line1] + this.dimensions.WIDTH;\n            if (this.xPos[line1] <= -this.dimensions.WIDTH) {\n                this.xPos[line1] += this.dimensions.WIDTH * 2;\n                this.xPos[line2] = this.xPos[line1] - this.dimensions.WIDTH;\n                this.sourceXPos[line1] = this.getRandomType() + this.spritePos.x;\n            }\n        },\n        /**\n         * Update the horizon line.\n         * @param {number} deltaTime\n         * @param {number} speed\n         */ update: function(deltaTime, speed) {\n            var increment = Math.floor(speed * (FPS / 1000) * deltaTime);\n            if (this.xPos[0] <= 0) this.updateXPos(0, increment);\n            else this.updateXPos(1, increment);\n            this.draw();\n        },\n        /**\n         * Reset horizon to the starting position.\n         */ reset: function() {\n            this.xPos[0] = 0;\n            this.xPos[1] = HorizonLine.dimensions.WIDTH;\n        }\n    };\n    //******************************************************************************\n    /**\n     * Horizon background class.\n     * @param {HTMLCanvasElement} canvas\n     * @param {Object} spritePos Sprite positioning.\n     * @param {Object} dimensions Canvas dimensions.\n     * @param {number} gapCoefficient\n     * @constructor\n     */ function Horizon(canvas, spritePos, dimensions, gapCoefficient) {\n        this.canvas = canvas;\n        this.canvasCtx = this.canvas.getContext('2d');\n        this.config = Horizon.config;\n        this.dimensions = dimensions;\n        this.gapCoefficient = gapCoefficient;\n        this.obstacles = [];\n        this.obstacleHistory = [];\n        this.horizonOffsets = [\n            0,\n            0\n        ];\n        this.cloudFrequency = this.config.CLOUD_FREQUENCY;\n        this.spritePos = spritePos;\n        this.nightMode = null;\n        // Cloud\n        this.clouds = [];\n        this.cloudSpeed = this.config.BG_CLOUD_SPEED;\n        // Horizon\n        this.horizonLine = null;\n        this.init();\n    }\n    /**\n     * Horizon config.\n     * @enum {number}\n     */ Horizon.config = {\n        BG_CLOUD_SPEED: 0.2,\n        BUMPY_THRESHOLD: .3,\n        CLOUD_FREQUENCY: .5,\n        HORIZON_HEIGHT: 16,\n        MAX_CLOUDS: 6\n    };\n    Horizon.prototype = {\n        /**\n         * Initialise the horizon. Just add the line and a cloud. No obstacles.\n         */ init: function() {\n            this.addCloud();\n            this.horizonLine = new HorizonLine(this.canvas, this.spritePos.HORIZON);\n            this.nightMode = new NightMode(this.canvas, this.spritePos.MOON, this.dimensions.WIDTH);\n        },\n        /**\n         * @param {number} deltaTime\n         * @param {number} currentSpeed\n         * @param {boolean} updateObstacles Used as an override to prevent\n         *     the obstacles from being updated / added. This happens in the\n         *     ease in section.\n         * @param {boolean} showNightMode Night mode activated.\n         */ update: function(deltaTime, currentSpeed, updateObstacles, showNightMode) {\n            this.runningTime += deltaTime;\n            this.horizonLine.update(deltaTime, currentSpeed);\n            this.nightMode.update(showNightMode);\n            this.updateClouds(deltaTime, currentSpeed);\n            if (updateObstacles) this.updateObstacles(deltaTime, currentSpeed);\n        },\n        /**\n         * Update the cloud positions.\n         * @param {number} deltaTime\n         * @param {number} currentSpeed\n         */ updateClouds: function(deltaTime, speed) {\n            var cloudSpeed = this.cloudSpeed / 1000 * deltaTime * speed;\n            var numClouds = this.clouds.length;\n            if (numClouds) {\n                for(var i = numClouds - 1; i >= 0; i--)this.clouds[i].update(cloudSpeed);\n                var lastCloud = this.clouds[numClouds - 1];\n                // Check for adding a new cloud.\n                if (numClouds < this.config.MAX_CLOUDS && this.dimensions.WIDTH - lastCloud.xPos > lastCloud.cloudGap && this.cloudFrequency > Math.random()) this.addCloud();\n                // Remove expired clouds.\n                this.clouds = this.clouds.filter(function(obj) {\n                    return !obj.remove;\n                });\n            } else this.addCloud();\n        },\n        /**\n         * Update the obstacle positions.\n         * @param {number} deltaTime\n         * @param {number} currentSpeed\n         */ updateObstacles: function(deltaTime, currentSpeed) {\n            // Obstacles, move to Horizon layer.\n            var updatedObstacles = this.obstacles.slice(0);\n            for(var i = 0; i < this.obstacles.length; i++){\n                var obstacle = this.obstacles[i];\n                obstacle.update(deltaTime, currentSpeed);\n                // Clean up existing obstacles.\n                if (obstacle.remove) updatedObstacles.shift();\n            }\n            this.obstacles = updatedObstacles;\n            if (this.obstacles.length > 0) {\n                var lastObstacle = this.obstacles[this.obstacles.length - 1];\n                if (lastObstacle && !lastObstacle.followingObstacleCreated && lastObstacle.isVisible() && lastObstacle.xPos + lastObstacle.width + lastObstacle.gap < this.dimensions.WIDTH) {\n                    this.addNewObstacle(currentSpeed);\n                    lastObstacle.followingObstacleCreated = true;\n                }\n            } else // Create new obstacles.\n            this.addNewObstacle(currentSpeed);\n        },\n        removeFirstObstacle: function() {\n            this.obstacles.shift();\n        },\n        /**\n         * Add a new obstacle.\n         * @param {number} currentSpeed\n         */ addNewObstacle: function(currentSpeed) {\n            var obstacleTypeIndex = getRandomNum(0, Obstacle.types.length - 1);\n            var obstacleType = Obstacle.types[obstacleTypeIndex];\n            // Check for multiples of the same type of obstacle.\n            // Also check obstacle is available at current speed.\n            if (this.duplicateObstacleCheck(obstacleType.type) || currentSpeed < obstacleType.minSpeed) this.addNewObstacle(currentSpeed);\n            else {\n                var obstacleSpritePos = this.spritePos[obstacleType.type];\n                this.obstacles.push(new Obstacle(this.canvasCtx, obstacleType, obstacleSpritePos, this.dimensions, this.gapCoefficient, currentSpeed, obstacleType.width));\n                this.obstacleHistory.unshift(obstacleType.type);\n                if (this.obstacleHistory.length > 1) this.obstacleHistory.splice(Runner1.config.MAX_OBSTACLE_DUPLICATION);\n            }\n        },\n        /**\n         * Returns whether the previous two obstacles are the same as the next one.\n         * Maximum duplication is set in config value MAX_OBSTACLE_DUPLICATION.\n         * @return {boolean}\n         */ duplicateObstacleCheck: function(nextObstacleType) {\n            var duplicateCount = 0;\n            for(var i = 0; i < this.obstacleHistory.length; i++)duplicateCount = this.obstacleHistory[i] == nextObstacleType ? duplicateCount + 1 : 0;\n            return duplicateCount >= Runner1.config.MAX_OBSTACLE_DUPLICATION;\n        },\n        /**\n         * Reset the horizon layer.\n         * Remove existing obstacles and reposition the horizon line.\n         */ reset: function() {\n            this.obstacles = [];\n            this.horizonLine.reset();\n            this.nightMode.reset();\n        },\n        /**\n         * Update the canvas width and scaling.\n         * @param {number} width Canvas width.\n         * @param {number} height Canvas height.\n         */ resize: function(width, height) {\n            this.canvas.width = width;\n            this.canvas.height = height;\n        },\n        /**\n         * Add a new cloud to the horizon.\n         */ addCloud: function() {\n            this.clouds.push(new Cloud(this.canvas, this.spritePos.CLOUD, this.dimensions.WIDTH));\n        }\n    };\n})();\nfunction onDocumentLoad() {\n    new Runner('.interstitial-wrapper');\n}\ndocument.addEventListener('DOMContentLoaded', onDocumentLoad);\n\n//# sourceMappingURL=index.3b645712.js.map\n","// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// extract from chromium source code by @liuwayong\n(function () {\n    'use strict';\n    /**\n     * T-Rex runner.\n     * @param {string} outerContainerId Outer containing element id.\n     * @param {Object} opt_config\n     * @constructor\n     * @export\n     */\n    function Runner(outerContainerId, opt_config) {\n        // Singleton\n        if (Runner.instance_) {\n            return Runner.instance_;\n        }\n        Runner.instance_ = this;\n\n        this.outerContainerEl = document.querySelector(outerContainerId);\n        this.containerEl = null;\n        this.snackbarEl = null;\n        this.detailsButton = this.outerContainerEl.querySelector('#details-button');\n\n        this.config = opt_config || Runner.config;\n\n        this.dimensions = Runner.defaultDimensions;\n\n        this.canvas = null;\n        this.canvasCtx = null;\n\n        this.tRex = null;\n\n        this.distanceMeter = null;\n        this.distanceRan = 0;\n\n        this.highestScore = 0;\n\n        this.time = 0;\n        this.runningTime = 0;\n        this.msPerFrame = 1000 / FPS;\n        this.currentSpeed = this.config.SPEED;\n\n        this.obstacles = [];\n\n        this.activated = false; // Whether the easter egg has been activated.\n        this.playing = false; // Whether the game is currently in play state.\n        this.crashed = false;\n        this.paused = false;\n        this.inverted = false;\n        this.invertTimer = 0;\n        this.resizeTimerId_ = null;\n\n        this.playCount = 0;\n\n        // Sound FX.\n        this.audioBuffer = null;\n        this.soundFx = {};\n\n        // Global web audio context for playing sounds.\n        this.audioContext = null;\n\n        // Images.\n        this.images = {};\n        this.imagesLoaded = 0;\n\n        if (this.isDisabled()) {\n            this.setupDisabledRunner();\n        } else {\n            this.loadImages();\n        }\n    }\n    window['Runner'] = Runner;\n\n\n    /**\n     * Default game width.\n     * @const\n     */\n    var DEFAULT_WIDTH = 600;\n\n    /**\n     * Frames per second.\n     * @const\n     */\n    var FPS = 60;\n\n    /** @const */\n    var IS_HIDPI = window.devicePixelRatio > 1;\n\n    /** @const */\n    var IS_IOS = /iPad|iPhone|iPod/.test(window.navigator.platform);\n\n    /** @const */\n    var IS_MOBILE = /Android/.test(window.navigator.userAgent) || IS_IOS;\n\n    /** @const */\n    var IS_TOUCH_ENABLED = 'ontouchstart' in window;\n\n    /**\n     * Default game configuration.\n     * @enum {number}\n     */\n    Runner.config = {\n        ACCELERATION: 0.001,\n        BG_CLOUD_SPEED: 0.2,\n        BOTTOM_PAD: 10,\n        CLEAR_TIME: 3000,\n        CLOUD_FREQUENCY: 0.5,\n        GAMEOVER_CLEAR_TIME: 750,\n        GAP_COEFFICIENT: 0.6,\n        GRAVITY: 0.6,\n        INITIAL_JUMP_VELOCITY: 12,\n        INVERT_FADE_DURATION: 12000,\n        INVERT_DISTANCE: 700,\n        MAX_BLINK_COUNT: 3,\n        MAX_CLOUDS: 6,\n        MAX_OBSTACLE_LENGTH: 3,\n        MAX_OBSTACLE_DUPLICATION: 2,\n        MAX_SPEED: 13,\n        MIN_JUMP_HEIGHT: 35,\n        MOBILE_SPEED_COEFFICIENT: 1.2,\n        RESOURCE_TEMPLATE_ID: 'audio-resources',\n        SPEED: 6,\n        SPEED_DROP_COEFFICIENT: 3,\n        ARCADE_MODE_INITIAL_TOP_POSITION: 100,\n        ARCADE_MODE_TOP_POSITION_PERCENT: 0\n    };\n\n\n    /**\n     * Default dimensions.\n     * @enum {string}\n     */\n    Runner.defaultDimensions = {\n        WIDTH: DEFAULT_WIDTH,\n        HEIGHT: 150\n    };\n\n\n    /**\n     * CSS class names.\n     * @enum {string}\n     */\n    Runner.classes = {\n        ARCADE_MODE: 'arcade-mode',\n        CANVAS: 'runner-canvas',\n        CONTAINER: 'runner-container',\n        CRASHED: 'crashed',\n        ICON: 'icon-offline',\n        INVERTED: 'inverted',\n        SNACKBAR: 'snackbar',\n        SNACKBAR_SHOW: 'snackbar-show',\n        TOUCH_CONTROLLER: 'controller'\n    };\n\n\n    /**\n     * Sprite definition layout of the spritesheet.\n     * @enum {Object}\n     */\n    Runner.spriteDefinition = {\n        LDPI: {\n            CACTUS_LARGE: { x: 332, y: 2 },\n            CACTUS_SMALL: { x: 228, y: 2 },\n            CLOUD: { x: 86, y: 2 },\n            HORIZON: { x: 2, y: 54 },\n            MOON: { x: 484, y: 2 },\n            PTERODACTYL: { x: 134, y: 2 },\n            RESTART: { x: 2, y: 2 },\n            TEXT_SPRITE: { x: 655, y: 2 },\n            TREX: { x: 848, y: 2 },\n            STAR: { x: 645, y: 2 }\n        },\n        HDPI: {\n            CACTUS_LARGE: { x: 652, y: 2 },\n            CACTUS_SMALL: { x: 446, y: 2 },\n            CLOUD: { x: 166, y: 2 },\n            HORIZON: { x: 2, y: 104 },\n            MOON: { x: 954, y: 2 },\n            PTERODACTYL: { x: 260, y: 2 },\n            RESTART: { x: 2, y: 2 },\n            TEXT_SPRITE: { x: 1294, y: 2 },\n            TREX: { x: 1678, y: 2 },\n            STAR: { x: 1276, y: 2 }\n        }\n    };\n\n\n    /**\n     * Sound FX. Reference to the ID of the audio tag on interstitial page.\n     * @enum {string}\n     */\n    Runner.sounds = {\n        BUTTON_PRESS: 'offline-sound-press',\n        HIT: 'offline-sound-hit',\n        SCORE: 'offline-sound-reached'\n    };\n\n\n    /**\n     * Key code mapping.\n     * @enum {Object}\n     */\n    Runner.keycodes = {\n        JUMP: { '38': 1, '32': 1 },  // Up, spacebar\n        DUCK: { '40': 1 },  // Down\n        RESTART: { '13': 1 }  // Enter\n    };\n\n\n    /**\n     * Runner event names.\n     * @enum {string}\n     */\n    Runner.events = {\n        ANIM_END: 'webkitAnimationEnd',\n        CLICK: 'click',\n        KEYDOWN: 'keydown',\n        KEYUP: 'keyup',\n        MOUSEDOWN: 'mousedown',\n        MOUSEUP: 'mouseup',\n        RESIZE: 'resize',\n        TOUCHEND: 'touchend',\n        TOUCHSTART: 'touchstart',\n        VISIBILITY: 'visibilitychange',\n        BLUR: 'blur',\n        FOCUS: 'focus',\n        LOAD: 'load'\n    };\n\n\n    Runner.prototype = {\n        /**\n         * Whether the easter egg has been disabled. CrOS enterprise enrolled devices.\n         * @return {boolean}\n         */\n        isDisabled: function () {\n            // return loadTimeData && loadTimeData.valueExists('disabledEasterEgg');\n            return false;\n        },\n\n        /**\n         * For disabled instances, set up a snackbar with the disabled message.\n         */\n        setupDisabledRunner: function () {\n            this.containerEl = document.createElement('div');\n            this.containerEl.className = Runner.classes.SNACKBAR;\n            this.containerEl.textContent = loadTimeData.getValue('disabledEasterEgg');\n            this.outerContainerEl.appendChild(this.containerEl);\n\n            // Show notification when the activation key is pressed.\n            document.addEventListener(Runner.events.KEYDOWN, function (e) {\n                if (Runner.keycodes.JUMP[e.keyCode]) {\n                    this.containerEl.classList.add(Runner.classes.SNACKBAR_SHOW);\n                    document.querySelector('.icon').classList.add('icon-disabled');\n                }\n            }.bind(this));\n        },\n\n        /**\n         * Setting individual settings for debugging.\n         * @param {string} setting\n         * @param {*} value\n         */\n        updateConfigSetting: function (setting, value) {\n            if (setting in this.config && value != undefined) {\n                this.config[setting] = value;\n\n                switch (setting) {\n                    case 'GRAVITY':\n                    case 'MIN_JUMP_HEIGHT':\n                    case 'SPEED_DROP_COEFFICIENT':\n                        this.tRex.config[setting] = value;\n                        break;\n                    case 'INITIAL_JUMP_VELOCITY':\n                        this.tRex.setJumpVelocity(value);\n                        break;\n                    case 'SPEED':\n                        this.setSpeed(value);\n                        break;\n                }\n            }\n        },\n\n        /**\n         * Cache the appropriate image sprite from the page and get the sprite sheet\n         * definition.\n         */\n        loadImages: function () {\n            if (IS_HIDPI) {\n                Runner.imageSprite = document.getElementById('offline-resources-2x');\n                this.spriteDef = Runner.spriteDefinition.HDPI;\n            } else {\n                Runner.imageSprite = document.getElementById('offline-resources-1x');\n                this.spriteDef = Runner.spriteDefinition.LDPI;\n            }\n\n            if (Runner.imageSprite.complete) {\n                this.init();\n            } else {\n                // If the images are not yet loaded, add a listener.\n                Runner.imageSprite.addEventListener(Runner.events.LOAD,\n                    this.init.bind(this));\n            }\n        },\n\n        /**\n         * Load and decode base 64 encoded sounds.\n         */\n        loadSounds: function () {\n            if (!IS_IOS) {\n                this.audioContext = new AudioContext();\n\n                var resourceTemplate =\n                    document.getElementById(this.config.RESOURCE_TEMPLATE_ID).content;\n\n                for (var sound in Runner.sounds) {\n                    var soundSrc =\n                        resourceTemplate.getElementById(Runner.sounds[sound]).src;\n                    soundSrc = soundSrc.substr(soundSrc.indexOf(',') + 1);\n                    var buffer = decodeBase64ToArrayBuffer(soundSrc);\n\n                    // Async, so no guarantee of order in array.\n                    this.audioContext.decodeAudioData(buffer, function (index, audioData) {\n                        this.soundFx[index] = audioData;\n                    }.bind(this, sound));\n                }\n            }\n        },\n\n        /**\n         * Sets the game speed. Adjust the speed accordingly if on a smaller screen.\n         * @param {number} opt_speed\n         */\n        setSpeed: function (opt_speed) {\n            var speed = opt_speed || this.currentSpeed;\n\n            // Reduce the speed on smaller mobile screens.\n            if (this.dimensions.WIDTH < DEFAULT_WIDTH) {\n                var mobileSpeed = speed * this.dimensions.WIDTH / DEFAULT_WIDTH *\n                    this.config.MOBILE_SPEED_COEFFICIENT;\n                this.currentSpeed = mobileSpeed > speed ? speed : mobileSpeed;\n            } else if (opt_speed) {\n                this.currentSpeed = opt_speed;\n            }\n        },\n\n        /**\n         * Game initialiser.\n         */\n        init: function () {\n            // Hide the static icon.\n            document.querySelector('.' + Runner.classes.ICON).style.visibility =\n                'hidden';\n\n            this.adjustDimensions();\n            this.setSpeed();\n\n            this.containerEl = document.createElement('div');\n            this.containerEl.className = Runner.classes.CONTAINER;\n\n            // Player canvas container.\n            this.canvas = createCanvas(this.containerEl, this.dimensions.WIDTH,\n                this.dimensions.HEIGHT, Runner.classes.PLAYER);\n\n            this.canvasCtx = this.canvas.getContext('2d');\n            this.canvasCtx.fillStyle = '#f7f7f7';\n            this.canvasCtx.fill();\n            Runner.updateCanvasScaling(this.canvas);\n\n            // Horizon contains clouds, obstacles and the ground.\n            this.horizon = new Horizon(this.canvas, this.spriteDef, this.dimensions,\n                this.config.GAP_COEFFICIENT);\n\n            // Distance meter\n            this.distanceMeter = new DistanceMeter(this.canvas,\n                this.spriteDef.TEXT_SPRITE, this.dimensions.WIDTH);\n\n            // Draw t-rex\n            this.tRex = new Trex(this.canvas, this.spriteDef.TREX);\n\n            this.outerContainerEl.appendChild(this.containerEl);\n\n            if (IS_MOBILE) {\n                this.createTouchController();\n            }\n\n            this.startListening();\n            this.update();\n\n            window.addEventListener(Runner.events.RESIZE,\n                this.debounceResize.bind(this));\n        },\n\n        /**\n         * Create the touch controller. A div that covers whole screen.\n         */\n        createTouchController: function () {\n            this.touchController = document.createElement('div');\n            this.touchController.className = Runner.classes.TOUCH_CONTROLLER;\n            this.outerContainerEl.appendChild(this.touchController);\n        },\n\n        /**\n         * Debounce the resize event.\n         */\n        debounceResize: function () {\n            if (!this.resizeTimerId_) {\n                this.resizeTimerId_ =\n                    setInterval(this.adjustDimensions.bind(this), 250);\n            }\n        },\n\n        /**\n         * Adjust game space dimensions on resize.\n         */\n        adjustDimensions: function () {\n            clearInterval(this.resizeTimerId_);\n            this.resizeTimerId_ = null;\n\n            var boxStyles = window.getComputedStyle(this.outerContainerEl);\n            var padding = Number(boxStyles.paddingLeft.substr(0,\n                boxStyles.paddingLeft.length - 2));\n\n            this.dimensions.WIDTH = this.outerContainerEl.offsetWidth - padding * 2;\n            this.dimensions.WIDTH = Math.min(DEFAULT_WIDTH, this.dimensions.WIDTH); //Arcade Mode\n            if (this.activated) {\n                this.setArcadeModeContainerScale();\n            }\n\n            // Redraw the elements back onto the canvas.\n            if (this.canvas) {\n                this.canvas.width = this.dimensions.WIDTH;\n                this.canvas.height = this.dimensions.HEIGHT;\n\n                Runner.updateCanvasScaling(this.canvas);\n\n                this.distanceMeter.calcXPos(this.dimensions.WIDTH);\n                this.clearCanvas();\n                this.horizon.update(0, 0, true);\n                this.tRex.update(0);\n\n                // Outer container and distance meter.\n                if (this.playing || this.crashed || this.paused) {\n                    this.containerEl.style.width = this.dimensions.WIDTH + 'px';\n                    this.containerEl.style.height = this.dimensions.HEIGHT + 'px';\n                    this.distanceMeter.update(0, Math.ceil(this.distanceRan));\n                    this.stop();\n                } else {\n                    this.tRex.draw(0, 0);\n                }\n\n                // Game over panel.\n                if (this.crashed && this.gameOverPanel) {\n                    this.gameOverPanel.updateDimensions(this.dimensions.WIDTH);\n                    this.gameOverPanel.draw();\n                }\n            }\n        },\n\n        /**\n         * Play the game intro.\n         * Canvas container width expands out to the full width.\n         */\n        playIntro: function () {\n            if (!this.activated && !this.crashed) {\n                this.playingIntro = true;\n                this.tRex.playingIntro = true;\n\n                // CSS animation definition.\n                var keyframes = '@-webkit-keyframes intro { ' +\n                    'from { width:' + Trex.config.WIDTH + 'px }' +\n                    'to { width: ' + this.dimensions.WIDTH + 'px }' +\n                    '}';\n\n                // create a style sheet to put the keyframe rule in\n                // and then place the style sheet in the html head\n                var sheet = document.createElement('style');\n                sheet.innerHTML = keyframes;\n                document.head.appendChild(sheet);\n\n                this.containerEl.addEventListener(Runner.events.ANIM_END,\n                    this.startGame.bind(this));\n\n                this.containerEl.style.webkitAnimation = 'intro .4s ease-out 1 both';\n                this.containerEl.style.width = this.dimensions.WIDTH + 'px';\n\n                // if (this.touchController) {\n                //     this.outerContainerEl.appendChild(this.touchController);\n                // }\n                this.playing = true;\n                this.activated = true;\n            } else if (this.crashed) {\n                this.restart();\n            }\n        },\n\n\n        /**\n         * Update the game status to started.\n         */\n        startGame: function () {\n            this.setArcadeMode();\n            this.runningTime = 0;\n            this.playingIntro = false;\n            this.tRex.playingIntro = false;\n            this.containerEl.style.webkitAnimation = '';\n            this.playCount++;\n\n            document.querySelector('#helpstart').style.visibility = 'hidden';\n            // Handle tabbing off the page. Pause the current game.\n            document.addEventListener(Runner.events.VISIBILITY,\n                this.onVisibilityChange.bind(this));\n\n            window.addEventListener(Runner.events.BLUR,\n                this.onVisibilityChange.bind(this));\n\n            window.addEventListener(Runner.events.FOCUS,\n                this.onVisibilityChange.bind(this));\n        },\n\n        clearCanvas: function () {\n            this.canvasCtx.clearRect(0, 0, this.dimensions.WIDTH,\n                this.dimensions.HEIGHT);\n        },\n\n        /**\n         * Update the game frame and schedules the next one.\n         */\n        update: function () {\n            this.updatePending = false;\n\n            var now = getTimeStamp();\n            var deltaTime = now - (this.time || now);\n            this.time = now;\n\n            if (this.playing) {\n                this.clearCanvas();\n\n                if (this.tRex.jumping) {\n                    this.tRex.updateJump(deltaTime);\n                }\n\n                this.runningTime += deltaTime;\n                var hasObstacles = this.runningTime > this.config.CLEAR_TIME;\n\n                // First jump triggers the intro.\n                if (this.tRex.jumpCount == 1 && !this.playingIntro) {\n                    this.playIntro();\n                }\n\n                // The horizon doesn't move until the intro is over.\n                if (this.playingIntro) {\n                    this.horizon.update(0, this.currentSpeed, hasObstacles);\n                } else {\n                    deltaTime = !this.activated ? 0 : deltaTime;\n                    this.horizon.update(deltaTime, this.currentSpeed, hasObstacles,\n                        this.inverted);\n                }\n\n                // Check for collisions.\n                var collision = hasObstacles &&\n                    checkForCollision(this.horizon.obstacles[0], this.tRex);\n\n                if (!collision) {\n                    this.distanceRan += this.currentSpeed * deltaTime / this.msPerFrame;\n\n                    if (this.currentSpeed < this.config.MAX_SPEED) {\n                        this.currentSpeed += this.config.ACCELERATION;\n                    }\n                } else {\n                    this.gameOver();\n                }\n\n                var playAchievementSound = this.distanceMeter.update(deltaTime,\n                    Math.ceil(this.distanceRan));\n\n                if (playAchievementSound) {\n                    this.playSound(this.soundFx.SCORE);\n                }\n\n                // Night mode.\n                if (this.invertTimer > this.config.INVERT_FADE_DURATION) {\n                    this.invertTimer = 0;\n                    this.invertTrigger = false;\n                    this.invert();\n                } else if (this.invertTimer) {\n                    this.invertTimer += deltaTime;\n                } else {\n                    var actualDistance =\n                        this.distanceMeter.getActualDistance(Math.ceil(this.distanceRan));\n\n                    if (actualDistance > 0) {\n                        this.invertTrigger = !(actualDistance %\n                            this.config.INVERT_DISTANCE);\n\n                        if (this.invertTrigger && this.invertTimer === 0) {\n                            this.invertTimer += deltaTime;\n                            this.invert();\n                        }\n                    }\n                }\n            }\n\n            if (this.playing || (!this.activated &&\n                this.tRex.blinkCount < Runner.config.MAX_BLINK_COUNT)) {\n                this.tRex.update(deltaTime);\n                this.scheduleNextUpdate();\n            }\n        },\n\n        /**\n         * Event handler.\n         */\n        handleEvent: function (e) {\n            return (function (evtType, events) {\n                switch (evtType) {\n                    case events.KEYDOWN:\n                    case events.TOUCHSTART:\n                    case events.MOUSEDOWN:\n                        this.onKeyDown(e);\n                        break;\n                    case events.KEYUP:\n                    case events.TOUCHEND:\n                    case events.MOUSEUP:\n                        this.onKeyUp(e);\n                        break;\n                }\n            }.bind(this))(e.type, Runner.events);\n        },\n\n        /**\n         * Bind relevant key / mouse / touch listeners.\n         */\n        startListening: function () {\n            // Keys.\n            document.addEventListener(Runner.events.KEYDOWN, this);\n            document.addEventListener(Runner.events.KEYUP, this);\n\n\n            if (IS_MOBILE) {\n                // Mobile only touch devices.\n                this.touchController.addEventListener(Runner.events.TOUCHSTART, this);\n                this.touchController.addEventListener(Runner.events.TOUCHEND, this);\n                this.containerEl.addEventListener(Runner.events.TOUCHSTART, this);\n            }\n            // Mouse.\n            document.addEventListener(Runner.events.MOUSEDOWN, this);\n            document.addEventListener(Runner.events.MOUSEUP, this);\n\n        },\n\n        /**\n         * Remove all listeners.\n         */\n        stopListening: function () {\n            document.removeEventListener(Runner.events.KEYDOWN, this);\n            document.removeEventListener(Runner.events.KEYUP, this);\n\n            if (IS_MOBILE) {\n                this.touchController.removeEventListener(Runner.events.TOUCHSTART, this);\n                this.touchController.removeEventListener(Runner.events.TOUCHEND, this);\n                this.containerEl.removeEventListener(Runner.events.TOUCHSTART, this);\n            } else {\n                document.removeEventListener(Runner.events.MOUSEDOWN, this);\n                document.removeEventListener(Runner.events.MOUSEUP, this);\n            }\n        },\n\n        /**\n         * Process keydown.\n         * @param {Event} e\n         */\n        onKeyDown: function (e) {\n            // Prevent native page scrolling whilst tapping on mobile.\n            if (IS_MOBILE && this.playing) {\n                e.preventDefault();\n            }\n\n            if (e.target != this.detailsButton) {\n\n                if (!this.crashed && (Runner.keycodes.JUMP[e.keyCode] ||\n                    e.type == Runner.events.TOUCHSTART || e.type == Runner.events.MOUSEDOWN)) {\n                    if (!this.playing) {\n                        this.loadSounds();\n                        this.playing = true;\n                        this.update();\n                        if (window.errorPageController) {\n                            errorPageController.trackEasterEgg();\n                        }\n                    }\n                    //  Play sound effect and jump on starting the game for the first time.\n                    if (!this.tRex.jumping && !this.tRex.ducking) {\n                        this.playSound(this.soundFx.BUTTON_PRESS);\n                        this.tRex.startJump(this.currentSpeed);\n                    }\n                }\n\n                if (this.crashed && e.type == Runner.events.TOUCHSTART &&\n\n                    e.currentTarget == this.containerEl) {\n\n                    this.restart();\n                }\n            }\n\n            if (this.playing && !this.crashed && Runner.keycodes.DUCK[e.keyCode]) {\n                e.preventDefault();\n                if (this.tRex.jumping) {\n                    // Speed drop, activated only when jump key is not pressed.\n                    this.tRex.setSpeedDrop();\n                } else if (!this.tRex.jumping && !this.tRex.ducking) {\n                    // Duck.\n                    this.tRex.setDuck(true);\n                }\n            }\n        },\n\n\n        /**\n         * Process key up.\n         * @param {Event} e\n         */\n        onKeyUp: function (e) {\n            var keyCode = String(e.keyCode);\n            var isjumpKey = Runner.keycodes.JUMP[keyCode] ||\n                e.type == Runner.events.TOUCHEND ||\n                e.type == Runner.events.MOUSEDOWN;\n\n            if (this.isRunning() && isjumpKey) {\n                this.tRex.endJump();\n            } else if (Runner.keycodes.DUCK[keyCode]) {\n                this.tRex.speedDrop = false;\n                this.tRex.setDuck(false);\n            } else if (this.crashed) {\n\n                // Check that enough time has elapsed before allowing jump key to restart.\n                var deltaTime = getTimeStamp() - this.time;\n\n                if (e.type == Runner.events.MOUSEUP || Runner.keycodes.RESTART[keyCode] || this.isLeftClickOnCanvas(e) ||\n                    (deltaTime >= this.config.GAMEOVER_CLEAR_TIME &&\n                        Runner.keycodes.JUMP[keyCode])) {\n                    this.restart();\n                }\n            } else if (this.paused && isjumpKey) {\n                // Reset the jump state\n                this.tRex.reset();\n                this.play();\n            }\n        },\n\n        /**\n         * Returns whether the event was a left click on canvas.\n         * On Windows right click is registered as a click.\n         * @param {Event} e\n         * @return {boolean}\n         */\n        isLeftClickOnCanvas: function (e) {\n            return e.button != null && e.button < 2 &&\n                e.type == Runner.events.MOUSEUP && e.target == this.canvas;\n        },\n\n        /**\n         * RequestAnimationFrame wrapper.\n         */\n        scheduleNextUpdate: function () {\n            if (!this.updatePending) {\n                this.updatePending = true;\n                this.raqId = requestAnimationFrame(this.update.bind(this));\n            }\n        },\n\n        /**\n         * Whether the game is running.\n         * @return {boolean}\n         */\n        isRunning: function () {\n            return !!this.raqId;\n        },\n\n        /**\n         * Game over state.\n         */\n        gameOver: function () {\n            this.playSound(this.soundFx.HIT);\n            vibrate(200);\n            document.querySelector('#gameover').style.visibility = 'visible';\n            this.stop();\n            this.crashed = true;\n            this.distanceMeter.acheivement = false;\n\n            this.tRex.update(100, Trex.status.CRASHED);\n\n            // Game over panel.\n            if (!this.gameOverPanel) {\n                this.gameOverPanel = new GameOverPanel(this.canvas,\n                    this.spriteDef.TEXT_SPRITE, this.spriteDef.RESTART,\n                    this.dimensions);\n            } else {\n                this.gameOverPanel.draw();\n            }\n\n            // Update the high score.\n            if (this.distanceRan > this.highestScore) {\n                this.highestScore = Math.ceil(this.distanceRan);\n                this.distanceMeter.setHighScore(this.highestScore);\n            }\n\n            // Reset the time clock.\n            this.time = getTimeStamp();\n        },\n\n        stop: function () {\n            this.playing = false;\n            this.paused = true;\n            cancelAnimationFrame(this.raqId);\n            this.raqId = 0;\n        },\n\n        play: function () {\n            if (!this.crashed) {\n                this.playing = true;\n                this.paused = false;\n                this.tRex.update(0, Trex.status.RUNNING);\n                this.time = getTimeStamp();\n                this.update();\n            }\n        },\n\n        restart: function () {\n            document.querySelector('#gameover').style.visibility = 'hidden'\n            if (!this.raqId) {\n                this.playCount++;\n                this.runningTime = 0;\n                this.playing = true;\n                this.crashed = false;\n                this.distanceRan = 0;\n                this.setSpeed(this.config.SPEED);\n                this.time = getTimeStamp();\n                this.containerEl.classList.remove(Runner.classes.CRASHED);\n                this.clearCanvas();\n                this.distanceMeter.reset(this.highestScore);\n                this.horizon.reset();\n                this.tRex.reset();\n                this.playSound(this.soundFx.BUTTON_PRESS);\n                this.invert(true);\n                this.update();\n            }\n        },\n\n        /**\n         * Hides offline messaging for a fullscreen game only experience.\n         */\n        setArcadeMode() {\n            document.body.classList.add(Runner.classes.ARCADE_MODE);\n            this.setArcadeModeContainerScale();\n        },\n\n        /**\n         * Sets the scaling for arcade mode.\n         */\n        setArcadeModeContainerScale() {\n            const windowHeight = window.innerHeight;\n            const scaleHeight = windowHeight / this.dimensions.HEIGHT;\n            const scaleWidth = window.innerWidth / this.dimensions.WIDTH;\n            const scale = Math.max(1, Math.min(scaleHeight, scaleWidth));\n            const scaledCanvasHeight = this.dimensions.HEIGHT * scale;\n            const translateY = (windowHeight - scaledCanvasHeight - Runner.config.ARCADE_MODE_INITIAL_TOP_POSITION);\n\n            const cssScale = scale;\n            this.containerEl.style.transform =\n                'scale(' + cssScale + ') translateY(' + translateY / scale + 'px)';\n        },\n\n        /**\n         * Pause the game if the tab is not in focus.\n         */\n        onVisibilityChange: function (e) {\n            if (document.hidden || document.webkitHidden || e.type == 'blur' ||\n                document.visibilityState != 'visible') {\n                this.stop();\n            } else if (!this.crashed) {\n                this.tRex.reset();\n                this.play();\n            }\n        },\n\n        /**\n         * Play a sound.\n         * @param {SoundBuffer} soundBuffer\n         */\n        playSound: function (soundBuffer) {\n            if (soundBuffer) {\n                var sourceNode = this.audioContext.createBufferSource();\n                sourceNode.buffer = soundBuffer;\n                sourceNode.connect(this.audioContext.destination);\n                sourceNode.start(0);\n            }\n        },\n\n        /**\n         * Inverts the current page / canvas colors.\n         * @param {boolean} Whether to reset colors.\n         */\n        invert: function (reset) {\n            if (reset) {\n                document.body.classList.toggle(Runner.classes.INVERTED, false);\n                this.invertTimer = 0;\n                this.inverted = false;\n            } else {\n                this.inverted = document.body.classList.toggle(Runner.classes.INVERTED,\n                    this.invertTrigger);\n            }\n        }\n    };\n\n\n    /**\n     * Updates the canvas size taking into\n     * account the backing store pixel ratio and\n     * the device pixel ratio.\n     *\n     * See article by Paul Lewis:\n     * http://www.html5rocks.com/en/tutorials/canvas/hidpi/\n     *\n     * @param {HTMLCanvasElement} canvas\n     * @param {number} opt_width\n     * @param {number} opt_height\n     * @return {boolean} Whether the canvas was scaled.\n     */\n    Runner.updateCanvasScaling = function (canvas, opt_width, opt_height) {\n        var context = canvas.getContext('2d');\n\n        // Query the various pixel ratios\n        var devicePixelRatio = Math.floor(window.devicePixelRatio) || 1;\n        var backingStoreRatio = Math.floor(context.webkitBackingStorePixelRatio) || 1;\n        var ratio = devicePixelRatio / backingStoreRatio;\n\n        // Upscale the canvas if the two ratios don't match\n        if (devicePixelRatio !== backingStoreRatio) {\n            var oldWidth = opt_width || canvas.width;\n            var oldHeight = opt_height || canvas.height;\n\n            canvas.width = oldWidth * ratio;\n            canvas.height = oldHeight * ratio;\n\n            canvas.style.width = oldWidth + 'px';\n            canvas.style.height = oldHeight + 'px';\n\n            // Scale the context to counter the fact that we've manually scaled\n            // our canvas element.\n            context.scale(ratio, ratio);\n            return true;\n        } else if (devicePixelRatio == 1) {\n            // Reset the canvas width / height. Fixes scaling bug when the page is\n            // zoomed and the devicePixelRatio changes accordingly.\n            canvas.style.width = canvas.width + 'px';\n            canvas.style.height = canvas.height + 'px';\n        }\n        return false;\n    };\n\n\n    /**\n     * Get random number.\n     * @param {number} min\n     * @param {number} max\n     * @param {number}\n     */\n    function getRandomNum(min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n\n\n    /**\n     * Vibrate on mobile devices.\n     * @param {number} duration Duration of the vibration in milliseconds.\n     */\n    function vibrate(duration) {\n        if (IS_MOBILE && window.navigator.vibrate) {\n            window.navigator.vibrate(duration);\n        }\n    }\n\n\n    /**\n     * Create canvas element.\n     * @param {HTMLElement} container Element to append canvas to.\n     * @param {number} width\n     * @param {number} height\n     * @param {string} opt_classname\n     * @return {HTMLCanvasElement}\n     */\n    function createCanvas(container, width, height, opt_classname) {\n        var canvas = document.createElement('canvas');\n        canvas.className = opt_classname ? Runner.classes.CANVAS + ' ' +\n            opt_classname : Runner.classes.CANVAS;\n        canvas.width = width;\n        canvas.height = height;\n        container.appendChild(canvas);\n\n        return canvas;\n    }\n\n\n    /**\n     * Decodes the base 64 audio to ArrayBuffer used by Web Audio.\n     * @param {string} base64String\n     */\n    function decodeBase64ToArrayBuffer(base64String) {\n        var len = (base64String.length / 4) * 3;\n        var str = atob(base64String);\n        var arrayBuffer = new ArrayBuffer(len);\n        var bytes = new Uint8Array(arrayBuffer);\n\n        for (var i = 0; i < len; i++) {\n            bytes[i] = str.charCodeAt(i);\n        }\n        return bytes.buffer;\n    }\n\n\n    /**\n     * Return the current timestamp.\n     * @return {number}\n     */\n    function getTimeStamp() {\n        return IS_IOS ? new Date().getTime() : performance.now();\n    }\n\n\n    //******************************************************************************\n\n\n    /**\n     * Game over panel.\n     * @param {!HTMLCanvasElement} canvas\n     * @param {Object} textImgPos\n     * @param {Object} restartImgPos\n     * @param {!Object} dimensions Canvas dimensions.\n     * @constructor\n     */\n    function GameOverPanel(canvas, textImgPos, restartImgPos, dimensions) {\n        this.canvas = canvas;\n        this.canvasCtx = canvas.getContext('2d');\n        this.canvasDimensions = dimensions;\n        this.textImgPos = textImgPos;\n        this.restartImgPos = restartImgPos;\n        this.draw();\n    };\n\n\n    /**\n     * Dimensions used in the panel.\n     * @enum {number}\n     */\n    GameOverPanel.dimensions = {\n        TEXT_X: 0,\n        TEXT_Y: 13,\n        TEXT_WIDTH: 191,\n        TEXT_HEIGHT: 11,\n        RESTART_WIDTH: 36,\n        RESTART_HEIGHT: 32\n    };\n\n\n    GameOverPanel.prototype = {\n        /**\n         * Update the panel dimensions.\n         * @param {number} width New canvas width.\n         * @param {number} opt_height Optional new canvas height.\n         */\n        updateDimensions: function (width, opt_height) {\n            this.canvasDimensions.WIDTH = width;\n            if (opt_height) {\n                this.canvasDimensions.HEIGHT = opt_height;\n            }\n        },\n\n        /**\n         * Draw the panel.\n         */\n        draw: function () {\n            var dimensions = GameOverPanel.dimensions;\n\n            var centerX = this.canvasDimensions.WIDTH / 2;\n\n            // Game over text.\n            var textSourceX = dimensions.TEXT_X;\n            var textSourceY = dimensions.TEXT_Y;\n            var textSourceWidth = dimensions.TEXT_WIDTH;\n            var textSourceHeight = dimensions.TEXT_HEIGHT;\n\n            var textTargetX = Math.round(centerX - (dimensions.TEXT_WIDTH / 2));\n            var textTargetY = Math.round((this.canvasDimensions.HEIGHT - 25) / 3);\n            var textTargetWidth = dimensions.TEXT_WIDTH;\n            var textTargetHeight = dimensions.TEXT_HEIGHT;\n\n            var restartSourceWidth = dimensions.RESTART_WIDTH;\n            var restartSourceHeight = dimensions.RESTART_HEIGHT;\n            var restartTargetX = centerX - (dimensions.RESTART_WIDTH / 2);\n            var restartTargetY = this.canvasDimensions.HEIGHT / 2;\n\n            if (IS_HIDPI) {\n                textSourceY *= 2;\n                textSourceX *= 2;\n                textSourceWidth *= 2;\n                textSourceHeight *= 2;\n                restartSourceWidth *= 2;\n                restartSourceHeight *= 2;\n            }\n\n            textSourceX += this.textImgPos.x;\n            textSourceY += this.textImgPos.y;\n\n            // Game over text from sprite.\n            this.canvasCtx.drawImage(Runner.imageSprite,\n                textSourceX, textSourceY, textSourceWidth, textSourceHeight,\n                textTargetX, textTargetY, textTargetWidth, textTargetHeight);\n\n            // Restart button.\n            this.canvasCtx.drawImage(Runner.imageSprite,\n                this.restartImgPos.x, this.restartImgPos.y,\n                restartSourceWidth, restartSourceHeight,\n                restartTargetX, restartTargetY, dimensions.RESTART_WIDTH,\n                dimensions.RESTART_HEIGHT);\n        }\n    };\n\n\n    //******************************************************************************\n\n    /**\n     * Check for a collision.\n     * @param {!Obstacle} obstacle\n     * @param {!Trex} tRex T-rex object.\n     * @param {HTMLCanvasContext} opt_canvasCtx Optional canvas context for drawing\n     *    collision boxes.\n     * @return {Array<CollisionBox>}\n     */\n    function checkForCollision(obstacle, tRex, opt_canvasCtx) {\n        var obstacleBoxXPos = Runner.defaultDimensions.WIDTH + obstacle.xPos;\n\n        // Adjustments are made to the bounding box as there is a 1 pixel white\n        // border around the t-rex and obstacles.\n        var tRexBox = new CollisionBox(\n            tRex.xPos + 1,\n            tRex.yPos + 1,\n            tRex.config.WIDTH - 2,\n            tRex.config.HEIGHT - 2);\n\n        var obstacleBox = new CollisionBox(\n            obstacle.xPos + 1,\n            obstacle.yPos + 1,\n            obstacle.typeConfig.width * obstacle.size - 2,\n            obstacle.typeConfig.height - 2);\n\n        // Debug outer box\n        if (opt_canvasCtx) {\n            drawCollisionBoxes(opt_canvasCtx, tRexBox, obstacleBox);\n        }\n\n        // Simple outer bounds check.\n        if (boxCompare(tRexBox, obstacleBox)) {\n            var collisionBoxes = obstacle.collisionBoxes;\n            var tRexCollisionBoxes = tRex.ducking ?\n                Trex.collisionBoxes.DUCKING : Trex.collisionBoxes.RUNNING;\n\n            // Detailed axis aligned box check.\n            for (var t = 0; t < tRexCollisionBoxes.length; t++) {\n                for (var i = 0; i < collisionBoxes.length; i++) {\n                    // Adjust the box to actual positions.\n                    var adjTrexBox =\n                        createAdjustedCollisionBox(tRexCollisionBoxes[t], tRexBox);\n                    var adjObstacleBox =\n                        createAdjustedCollisionBox(collisionBoxes[i], obstacleBox);\n                    var crashed = boxCompare(adjTrexBox, adjObstacleBox);\n\n                    // Draw boxes for debug.\n                    if (opt_canvasCtx) {\n                        drawCollisionBoxes(opt_canvasCtx, adjTrexBox, adjObstacleBox);\n                    }\n\n                    if (crashed) {\n                        return [adjTrexBox, adjObstacleBox];\n                    }\n                }\n            }\n        }\n        return false;\n    };\n\n\n    /**\n     * Adjust the collision box.\n     * @param {!CollisionBox} box The original box.\n     * @param {!CollisionBox} adjustment Adjustment box.\n     * @return {CollisionBox} The adjusted collision box object.\n     */\n    function createAdjustedCollisionBox(box, adjustment) {\n        return new CollisionBox(\n            box.x + adjustment.x,\n            box.y + adjustment.y,\n            box.width,\n            box.height);\n    };\n\n\n    /**\n     * Draw the collision boxes for debug.\n     */\n    function drawCollisionBoxes(canvasCtx, tRexBox, obstacleBox) {\n        canvasCtx.save();\n        canvasCtx.strokeStyle = '#f00';\n        canvasCtx.strokeRect(tRexBox.x, tRexBox.y, tRexBox.width, tRexBox.height);\n\n        canvasCtx.strokeStyle = '#0f0';\n        canvasCtx.strokeRect(obstacleBox.x, obstacleBox.y,\n            obstacleBox.width, obstacleBox.height);\n        canvasCtx.restore();\n    };\n\n\n    /**\n     * Compare two collision boxes for a collision.\n     * @param {CollisionBox} tRexBox\n     * @param {CollisionBox} obstacleBox\n     * @return {boolean} Whether the boxes intersected.\n     */\n    function boxCompare(tRexBox, obstacleBox) {\n        var crashed = false;\n        var tRexBoxX = tRexBox.x;\n        var tRexBoxY = tRexBox.y;\n\n        var obstacleBoxX = obstacleBox.x;\n        var obstacleBoxY = obstacleBox.y;\n\n        // Axis-Aligned Bounding Box method.\n        if (tRexBox.x < obstacleBoxX + obstacleBox.width &&\n            tRexBox.x + tRexBox.width > obstacleBoxX &&\n            tRexBox.y < obstacleBox.y + obstacleBox.height &&\n            tRexBox.height + tRexBox.y > obstacleBox.y) {\n            crashed = true;\n        }\n\n        return crashed;\n    };\n\n\n    //******************************************************************************\n\n    /**\n     * Collision box object.\n     * @param {number} x X position.\n     * @param {number} y Y Position.\n     * @param {number} w Width.\n     * @param {number} h Height.\n     */\n    function CollisionBox(x, y, w, h) {\n        this.x = x;\n        this.y = y;\n        this.width = w;\n        this.height = h;\n    };\n\n\n    //******************************************************************************\n\n    /**\n     * Obstacle.\n     * @param {HTMLCanvasCtx} canvasCtx\n     * @param {Obstacle.type} type\n     * @param {Object} spritePos Obstacle position in sprite.\n     * @param {Object} dimensions\n     * @param {number} gapCoefficient Mutipler in determining the gap.\n     * @param {number} speed\n     * @param {number} opt_xOffset\n     */\n    function Obstacle(canvasCtx, type, spriteImgPos, dimensions,\n        gapCoefficient, speed, opt_xOffset) {\n\n        this.canvasCtx = canvasCtx;\n        this.spritePos = spriteImgPos;\n        this.typeConfig = type;\n        this.gapCoefficient = gapCoefficient;\n        this.size = getRandomNum(1, Obstacle.MAX_OBSTACLE_LENGTH);\n        this.dimensions = dimensions;\n        this.remove = false;\n        this.xPos = dimensions.WIDTH + (opt_xOffset || 0);\n        this.yPos = 0;\n        this.width = 0;\n        this.collisionBoxes = [];\n        this.gap = 0;\n        this.speedOffset = 0;\n\n        // For animated obstacles.\n        this.currentFrame = 0;\n        this.timer = 0;\n\n        this.init(speed);\n    };\n\n    /**\n     * Coefficient for calculating the maximum gap.\n     * @const\n     */\n    Obstacle.MAX_GAP_COEFFICIENT = 1.5;\n\n    /**\n     * Maximum obstacle grouping count.\n     * @const\n     */\n    Obstacle.MAX_OBSTACLE_LENGTH = 3,\n\n\n        Obstacle.prototype = {\n            /**\n             * Initialise the DOM for the obstacle.\n             * @param {number} speed\n             */\n            init: function (speed) {\n                this.cloneCollisionBoxes();\n\n                // Only allow sizing if we're at the right speed.\n                if (this.size > 1 && this.typeConfig.multipleSpeed > speed) {\n                    this.size = 1;\n                }\n\n                this.width = this.typeConfig.width * this.size;\n\n                // Check if obstacle can be positioned at various heights.\n                if (Array.isArray(this.typeConfig.yPos)) {\n                    var yPosConfig = IS_MOBILE ? this.typeConfig.yPosMobile :\n                        this.typeConfig.yPos;\n                    this.yPos = yPosConfig[getRandomNum(0, yPosConfig.length - 1)];\n                } else {\n                    this.yPos = this.typeConfig.yPos;\n                }\n\n                this.draw();\n\n                // Make collision box adjustments,\n                // Central box is adjusted to the size as one box.\n                //      ____        ______        ________\n                //    _|   |-|    _|     |-|    _|       |-|\n                //   | |<->| |   | |<--->| |   | |<----->| |\n                //   | | 1 | |   | |  2  | |   | |   3   | |\n                //   |_|___|_|   |_|_____|_|   |_|_______|_|\n                //\n                if (this.size > 1) {\n                    this.collisionBoxes[1].width = this.width - this.collisionBoxes[0].width -\n                        this.collisionBoxes[2].width;\n                    this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width;\n                }\n\n                // For obstacles that go at a different speed from the horizon.\n                if (this.typeConfig.speedOffset) {\n                    this.speedOffset = Math.random() > 0.5 ? this.typeConfig.speedOffset :\n                        -this.typeConfig.speedOffset;\n                }\n\n                this.gap = this.getGap(this.gapCoefficient, speed);\n            },\n\n            /**\n             * Draw and crop based on size.\n             */\n            draw: function () {\n                var sourceWidth = this.typeConfig.width;\n                var sourceHeight = this.typeConfig.height;\n\n                if (IS_HIDPI) {\n                    sourceWidth = sourceWidth * 2;\n                    sourceHeight = sourceHeight * 2;\n                }\n\n                // X position in sprite.\n                var sourceX = (sourceWidth * this.size) * (0.5 * (this.size - 1)) +\n                    this.spritePos.x;\n\n                // Animation frames.\n                if (this.currentFrame > 0) {\n                    sourceX += sourceWidth * this.currentFrame;\n                }\n\n                this.canvasCtx.drawImage(Runner.imageSprite,\n                    sourceX, this.spritePos.y,\n                    sourceWidth * this.size, sourceHeight,\n                    this.xPos, this.yPos,\n                    this.typeConfig.width * this.size, this.typeConfig.height);\n            },\n\n            /**\n             * Obstacle frame update.\n             * @param {number} deltaTime\n             * @param {number} speed\n             */\n            update: function (deltaTime, speed) {\n                if (!this.remove) {\n                    if (this.typeConfig.speedOffset) {\n                        speed += this.speedOffset;\n                    }\n                    this.xPos -= Math.floor((speed * FPS / 1000) * deltaTime);\n\n                    // Update frame\n                    if (this.typeConfig.numFrames) {\n                        this.timer += deltaTime;\n                        if (this.timer >= this.typeConfig.frameRate) {\n                            this.currentFrame =\n                                this.currentFrame == this.typeConfig.numFrames - 1 ?\n                                    0 : this.currentFrame + 1;\n                            this.timer = 0;\n                        }\n                    }\n                    this.draw();\n\n                    if (!this.isVisible()) {\n                        this.remove = true;\n                    }\n                }\n            },\n\n            /**\n             * Calculate a random gap size.\n             * - Minimum gap gets wider as speed increses\n             * @param {number} gapCoefficient\n             * @param {number} speed\n             * @return {number} The gap size.\n             */\n            getGap: function (gapCoefficient, speed) {\n                var minGap = Math.round(this.width * speed +\n                    this.typeConfig.minGap * gapCoefficient);\n                var maxGap = Math.round(minGap * Obstacle.MAX_GAP_COEFFICIENT);\n                return getRandomNum(minGap, maxGap);\n            },\n\n            /**\n             * Check if obstacle is visible.\n             * @return {boolean} Whether the obstacle is in the game area.\n             */\n            isVisible: function () {\n                return this.xPos + this.width > 0;\n            },\n\n            /**\n             * Make a copy of the collision boxes, since these will change based on\n             * obstacle type and size.\n             */\n            cloneCollisionBoxes: function () {\n                var collisionBoxes = this.typeConfig.collisionBoxes;\n\n                for (var i = collisionBoxes.length - 1; i >= 0; i--) {\n                    this.collisionBoxes[i] = new CollisionBox(collisionBoxes[i].x,\n                        collisionBoxes[i].y, collisionBoxes[i].width,\n                        collisionBoxes[i].height);\n                }\n            }\n        };\n\n\n    /**\n     * Obstacle definitions.\n     * minGap: minimum pixel space betweeen obstacles.\n     * multipleSpeed: Speed at which multiples are allowed.\n     * speedOffset: speed faster / slower than the horizon.\n     * minSpeed: Minimum speed which the obstacle can make an appearance.\n     */\n    Obstacle.types = [\n        {\n            type: 'CACTUS_SMALL',\n            width: 17,\n            height: 35,\n            yPos: 105,\n            multipleSpeed: 4,\n            minGap: 120,\n            minSpeed: 0,\n            collisionBoxes: [\n                new CollisionBox(0, 7, 5, 27),\n                new CollisionBox(4, 0, 6, 34),\n                new CollisionBox(10, 4, 7, 14)\n            ]\n        },\n        {\n            type: 'CACTUS_LARGE',\n            width: 25,\n            height: 50,\n            yPos: 90,\n            multipleSpeed: 7,\n            minGap: 120,\n            minSpeed: 0,\n            collisionBoxes: [\n                new CollisionBox(0, 12, 7, 38),\n                new CollisionBox(8, 0, 7, 49),\n                new CollisionBox(13, 10, 10, 38)\n            ]\n        },\n        {\n            type: 'PTERODACTYL',\n            width: 46,\n            height: 40,\n            yPos: [100, 75, 50], // Variable height.\n            yPosMobile: [100, 50], // Variable height mobile.\n            multipleSpeed: 999,\n            minSpeed: 8.5,\n            minGap: 150,\n            collisionBoxes: [\n                new CollisionBox(15, 15, 16, 5),\n                new CollisionBox(18, 21, 24, 6),\n                new CollisionBox(2, 14, 4, 3),\n                new CollisionBox(6, 10, 4, 7),\n                new CollisionBox(10, 8, 6, 9)\n            ],\n            numFrames: 2,\n            frameRate: 1000 / 6,\n            speedOffset: .8\n        }\n    ];\n\n\n    //******************************************************************************\n    /**\n     * T-rex game character.\n     * @param {HTMLCanvas} canvas\n     * @param {Object} spritePos Positioning within image sprite.\n     * @constructor\n     */\n    function Trex(canvas, spritePos) {\n        this.canvas = canvas;\n        this.canvasCtx = canvas.getContext('2d');\n        this.spritePos = spritePos;\n        this.xPos = 0;\n        this.yPos = 0;\n        // Position when on the ground.\n        this.groundYPos = 0;\n        this.currentFrame = 0;\n        this.currentAnimFrames = [];\n        this.blinkDelay = 0;\n        this.blinkCount = 0;\n        this.animStartTime = 0;\n        this.timer = 0;\n        this.msPerFrame = 1000 / FPS;\n        this.config = Trex.config;\n        // Current status.\n        this.status = Trex.status.WAITING;\n\n        this.jumping = false;\n        this.ducking = false;\n        this.jumpVelocity = 0;\n        this.reachedMinHeight = false;\n        this.speedDrop = false;\n        this.jumpCount = 0;\n        this.jumpspotX = 0;\n\n        this.init();\n    };\n\n\n    /**\n     * T-rex player config.\n     * @enum {number}\n     */\n    Trex.config = {\n        DROP_VELOCITY: -5,\n        GRAVITY: 0.6,\n        HEIGHT: 47,\n        HEIGHT_DUCK: 25,\n        INIITAL_JUMP_VELOCITY: -10,\n        INTRO_DURATION: 1500,\n        MAX_JUMP_HEIGHT: 30,\n        MIN_JUMP_HEIGHT: 30,\n        SPEED_DROP_COEFFICIENT: 3,\n        SPRITE_WIDTH: 262,\n        START_X_POS: 50,\n        WIDTH: 44,\n        WIDTH_DUCK: 59\n    };\n\n\n    /**\n     * Used in collision detection.\n     * @type {Array<CollisionBox>}\n     */\n    Trex.collisionBoxes = {\n        DUCKING: [\n            new CollisionBox(1, 18, 55, 25)\n        ],\n        RUNNING: [\n            new CollisionBox(22, 0, 17, 16),\n            new CollisionBox(1, 18, 30, 9),\n            new CollisionBox(10, 35, 14, 8),\n            new CollisionBox(1, 24, 29, 5),\n            new CollisionBox(5, 30, 21, 4),\n            new CollisionBox(9, 34, 15, 4)\n        ]\n    };\n\n\n    /**\n     * Animation states.\n     * @enum {string}\n     */\n    Trex.status = {\n        CRASHED: 'CRASHED',\n        DUCKING: 'DUCKING',\n        JUMPING: 'JUMPING',\n        RUNNING: 'RUNNING',\n        WAITING: 'WAITING'\n    };\n\n    /**\n     * Blinking coefficient.\n     * @const\n     */\n    Trex.BLINK_TIMING = 7000;\n\n\n    /**\n     * Animation config for different states.\n     * @enum {Object}\n     */\n    Trex.animFrames = {\n        WAITING: {\n            frames: [44, 0],\n            msPerFrame: 1000 / 3\n        },\n        RUNNING: {\n            frames: [88, 132],\n            msPerFrame: 1000 / 12\n        },\n        CRASHED: {\n            frames: [220],\n            msPerFrame: 1000 / 60\n        },\n        JUMPING: {\n            frames: [0],\n            msPerFrame: 1000 / 60\n        },\n        DUCKING: {\n            frames: [264, 323],\n            msPerFrame: 1000 / 8\n        }\n    };\n\n\n    Trex.prototype = {\n        /**\n         * T-rex player initaliser.\n         * Sets the t-rex to blink at random intervals.\n         */\n        init: function () {\n            this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -\n                Runner.config.BOTTOM_PAD;\n            this.yPos = this.groundYPos;\n            this.minJumpHeight = this.groundYPos - this.config.MIN_JUMP_HEIGHT;\n\n            this.draw(0, 0);\n            this.update(0, Trex.status.WAITING);\n        },\n\n        /**\n         * Setter for the jump velocity.\n         * The approriate drop velocity is also set.\n         */\n        setJumpVelocity: function (setting) {\n            this.config.INIITAL_JUMP_VELOCITY = -setting;\n            this.config.DROP_VELOCITY = -setting / 2;\n        },\n\n        /**\n         * Set the animation status.\n         * @param {!number} deltaTime\n         * @param {Trex.status} status Optional status to switch to.\n         */\n        update: function (deltaTime, opt_status) {\n            this.timer += deltaTime;\n\n            // Update the status.\n            if (opt_status) {\n                this.status = opt_status;\n                this.currentFrame = 0;\n                this.msPerFrame = Trex.animFrames[opt_status].msPerFrame;\n                this.currentAnimFrames = Trex.animFrames[opt_status].frames;\n\n                if (opt_status == Trex.status.WAITING) {\n                    this.animStartTime = getTimeStamp();\n                    this.setBlinkDelay();\n                }\n            }\n\n            // Game intro animation, T-rex moves in from the left.\n            if (this.playingIntro && this.xPos < this.config.START_X_POS) {\n                this.xPos += Math.round((this.config.START_X_POS /\n                    this.config.INTRO_DURATION) * deltaTime);\n            }\n\n            if (this.status == Trex.status.WAITING) {\n                this.blink(getTimeStamp());\n            } else {\n                this.draw(this.currentAnimFrames[this.currentFrame], 0);\n            }\n\n            // Update the frame position.\n            if (this.timer >= this.msPerFrame) {\n                this.currentFrame = this.currentFrame ==\n                    this.currentAnimFrames.length - 1 ? 0 : this.currentFrame + 1;\n                this.timer = 0;\n            }\n\n            // Speed drop becomes duck if the down key is still being pressed.\n            if (this.speedDrop && this.yPos == this.groundYPos) {\n                this.speedDrop = false;\n                this.setDuck(true);\n            }\n        },\n\n        /**\n         * Draw the t-rex to a particular position.\n         * @param {number} x\n         * @param {number} y\n         */\n        draw: function (x, y) {\n            var sourceX = x;\n            var sourceY = y;\n            var sourceWidth = this.ducking && this.status != Trex.status.CRASHED ?\n                this.config.WIDTH_DUCK : this.config.WIDTH;\n            var sourceHeight = this.config.HEIGHT;\n\n            if (IS_HIDPI) {\n                sourceX *= 2;\n                sourceY *= 2;\n                sourceWidth *= 2;\n                sourceHeight *= 2;\n            }\n\n            // Adjustments for sprite sheet position.\n            sourceX += this.spritePos.x;\n            sourceY += this.spritePos.y;\n\n            // Ducking.\n            if (this.ducking && this.status != Trex.status.CRASHED) {\n                this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,\n                    sourceWidth, sourceHeight,\n                    this.xPos, this.yPos,\n                    this.config.WIDTH_DUCK, this.config.HEIGHT);\n            } else {\n                // Crashed whilst ducking. Trex is standing up so needs adjustment.\n                if (this.ducking && this.status == Trex.status.CRASHED) {\n                    this.xPos++;\n                }\n                // Standing / running\n                this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,\n                    sourceWidth, sourceHeight,\n                    this.xPos, this.yPos,\n                    this.config.WIDTH, this.config.HEIGHT);\n            }\n        },\n\n        /**\n         * Sets a random time for the blink to happen.\n         */\n        setBlinkDelay: function () {\n            this.blinkDelay = Math.ceil(Math.random() * Trex.BLINK_TIMING);\n        },\n\n        /**\n         * Make t-rex blink at random intervals.\n         * @param {number} time Current time in milliseconds.\n         */\n        blink: function (time) {\n            var deltaTime = time - this.animStartTime;\n\n            if (deltaTime >= this.blinkDelay) {\n                this.draw(this.currentAnimFrames[this.currentFrame], 0);\n\n                if (this.currentFrame == 1) {\n                    // Set new random delay to blink.\n                    this.setBlinkDelay();\n                    this.animStartTime = time;\n                    this.blinkCount++;\n                }\n            }\n        },\n\n        /**\n         * Initialise a jump.\n         * @param {number} speed\n         */\n        startJump: function (speed) {\n            if (!this.jumping) {\n                this.update(0, Trex.status.JUMPING);\n                // Tweak the jump velocity based on the speed.\n                this.jumpVelocity = this.config.INIITAL_JUMP_VELOCITY - (speed / 10);\n                this.jumping = true;\n                this.reachedMinHeight = false;\n                this.speedDrop = false;\n            }\n        },\n\n        /**\n         * Jump is complete, falling down.\n         */\n        endJump: function () {\n            if (this.reachedMinHeight &&\n                this.jumpVelocity < this.config.DROP_VELOCITY) {\n                this.jumpVelocity = this.config.DROP_VELOCITY;\n            }\n        },\n\n        /**\n         * Update frame for a jump.\n         * @param {number} deltaTime\n         * @param {number} speed\n         */\n        updateJump: function (deltaTime, speed) {\n            var msPerFrame = Trex.animFrames[this.status].msPerFrame;\n            var framesElapsed = deltaTime / msPerFrame;\n\n            // Speed drop makes Trex fall faster.\n            if (this.speedDrop) {\n                this.yPos += Math.round(this.jumpVelocity *\n                    this.config.SPEED_DROP_COEFFICIENT * framesElapsed);\n            } else {\n                this.yPos += Math.round(this.jumpVelocity * framesElapsed);\n            }\n\n            this.jumpVelocity += this.config.GRAVITY * framesElapsed;\n\n            // Minimum height has been reached.\n            if (this.yPos < this.minJumpHeight || this.speedDrop) {\n                this.reachedMinHeight = true;\n            }\n\n            // Reached max height\n            if (this.yPos < this.config.MAX_JUMP_HEIGHT || this.speedDrop) {\n                this.endJump();\n            }\n\n            // Back down at ground level. Jump completed.\n            if (this.yPos > this.groundYPos) {\n                this.reset();\n                this.jumpCount++;\n            }\n\n            this.update(deltaTime);\n        },\n\n        /**\n         * Set the speed drop. Immediately cancels the current jump.\n         */\n        setSpeedDrop: function () {\n            this.speedDrop = true;\n            this.jumpVelocity = 1;\n        },\n\n        /**\n         * @param {boolean} isDucking.\n         */\n        setDuck: function (isDucking) {\n            if (isDucking && this.status != Trex.status.DUCKING) {\n                this.update(0, Trex.status.DUCKING);\n                this.ducking = true;\n            } else if (this.status == Trex.status.DUCKING) {\n                this.update(0, Trex.status.RUNNING);\n                this.ducking = false;\n            }\n        },\n\n        /**\n         * Reset the t-rex to running at start of game.\n         */\n        reset: function () {\n            this.yPos = this.groundYPos;\n            this.jumpVelocity = 0;\n            this.jumping = false;\n            this.ducking = false;\n            this.update(0, Trex.status.RUNNING);\n            this.midair = false;\n            this.speedDrop = false;\n            this.jumpCount = 0;\n        }\n    };\n\n\n    //******************************************************************************\n\n    /**\n     * Handles displaying the distance meter.\n     * @param {!HTMLCanvasElement} canvas\n     * @param {Object} spritePos Image position in sprite.\n     * @param {number} canvasWidth\n     * @constructor\n     */\n    function DistanceMeter(canvas, spritePos, canvasWidth) {\n        this.canvas = canvas;\n        this.canvasCtx = canvas.getContext('2d');\n        this.image = Runner.imageSprite;\n        this.spritePos = spritePos;\n        this.x = 0;\n        this.y = 5;\n\n        this.currentDistance = 0;\n        this.maxScore = 0;\n        this.highScore = 0;\n        this.container = null;\n\n        this.digits = [];\n        this.acheivement = false;\n        this.defaultString = '';\n        this.flashTimer = 0;\n        this.flashIterations = 0;\n        this.invertTrigger = false;\n\n        this.config = DistanceMeter.config;\n        this.maxScoreUnits = this.config.MAX_DISTANCE_UNITS;\n        this.init(canvasWidth);\n    };\n\n\n    /**\n     * @enum {number}\n     */\n    DistanceMeter.dimensions = {\n        WIDTH: 10,\n        HEIGHT: 13,\n        DEST_WIDTH: 11\n    };\n\n\n    /**\n     * Y positioning of the digits in the sprite sheet.\n     * X position is always 0.\n     * @type {Array<number>}\n     */\n    DistanceMeter.yPos = [0, 13, 27, 40, 53, 67, 80, 93, 107, 120];\n\n\n    /**\n     * Distance meter config.\n     * @enum {number}\n     */\n    DistanceMeter.config = {\n        // Number of digits.\n        MAX_DISTANCE_UNITS: 5,\n\n        // Distance that causes achievement animation.\n        ACHIEVEMENT_DISTANCE: 100,\n\n        // Used for conversion from pixel distance to a scaled unit.\n        COEFFICIENT: 0.025,\n\n        // Flash duration in milliseconds.\n        FLASH_DURATION: 1000 / 4,\n\n        // Flash iterations for achievement animation.\n        FLASH_ITERATIONS: 3\n    };\n\n\n    DistanceMeter.prototype = {\n        /**\n         * Initialise the distance meter to '00000'.\n         * @param {number} width Canvas width in px.\n         */\n        init: function (width) {\n            var maxDistanceStr = '';\n\n            this.calcXPos(width);\n            this.maxScore = this.maxScoreUnits;\n            for (var i = 0; i < this.maxScoreUnits; i++) {\n                this.draw(i, 0);\n                this.defaultString += '0';\n                maxDistanceStr += '9';\n            }\n\n            this.maxScore = parseInt(maxDistanceStr);\n        },\n\n        /**\n         * Calculate the xPos in the canvas.\n         * @param {number} canvasWidth\n         */\n        calcXPos: function (canvasWidth) {\n            this.x = canvasWidth - (DistanceMeter.dimensions.DEST_WIDTH *\n                (this.maxScoreUnits + 1));\n        },\n\n        /**\n         * Draw a digit to canvas.\n         * @param {number} digitPos Position of the digit.\n         * @param {number} value Digit value 0-9.\n         * @param {boolean} opt_highScore Whether drawing the high score.\n         */\n        draw: function (digitPos, value, opt_highScore) {\n            var sourceWidth = DistanceMeter.dimensions.WIDTH;\n            var sourceHeight = DistanceMeter.dimensions.HEIGHT;\n            var sourceX = DistanceMeter.dimensions.WIDTH * value;\n            var sourceY = 0;\n\n            var targetX = digitPos * DistanceMeter.dimensions.DEST_WIDTH;\n            var targetY = this.y;\n            var targetWidth = DistanceMeter.dimensions.WIDTH;\n            var targetHeight = DistanceMeter.dimensions.HEIGHT;\n\n            // For high DPI we 2x source values.\n            if (IS_HIDPI) {\n                sourceWidth *= 2;\n                sourceHeight *= 2;\n                sourceX *= 2;\n            }\n\n            sourceX += this.spritePos.x;\n            sourceY += this.spritePos.y;\n\n            this.canvasCtx.save();\n\n            if (opt_highScore) {\n                // Left of the current score.\n                var highScoreX = this.x - (this.maxScoreUnits * 2) *\n                    DistanceMeter.dimensions.WIDTH;\n                this.canvasCtx.translate(highScoreX, this.y);\n            } else {\n                this.canvasCtx.translate(this.x, this.y);\n            }\n\n            this.canvasCtx.drawImage(this.image, sourceX, sourceY,\n                sourceWidth, sourceHeight,\n                targetX, targetY,\n                targetWidth, targetHeight\n            );\n\n            this.canvasCtx.restore();\n        },\n\n        /**\n         * Covert pixel distance to a 'real' distance.\n         * @param {number} distance Pixel distance ran.\n         * @return {number} The 'real' distance ran.\n         */\n        getActualDistance: function (distance) {\n            return distance ? Math.round(distance * this.config.COEFFICIENT) : 0;\n        },\n\n        /**\n         * Update the distance meter.\n         * @param {number} distance\n         * @param {number} deltaTime\n         * @return {boolean} Whether the acheivement sound fx should be played.\n         */\n        update: function (deltaTime, distance) {\n            var paint = true;\n            var playSound = false;\n\n            if (!this.acheivement) {\n                distance = this.getActualDistance(distance);\n                // Score has gone beyond the initial digit count.\n                if (distance > this.maxScore && this.maxScoreUnits ==\n                    this.config.MAX_DISTANCE_UNITS) {\n                    this.maxScoreUnits++;\n                    this.maxScore = parseInt(this.maxScore + '9');\n                } else {\n                    this.distance = 0;\n                }\n\n                if (distance > 0) {\n                    // Acheivement unlocked\n                    if (distance % this.config.ACHIEVEMENT_DISTANCE == 0) {\n                        // Flash score and play sound.\n                        this.acheivement = true;\n                        this.flashTimer = 0;\n                        playSound = true;\n                    }\n\n                    // Create a string representation of the distance with leading 0.\n                    var distanceStr = (this.defaultString +\n                        distance).substr(-this.maxScoreUnits);\n                    this.digits = distanceStr.split('');\n                } else {\n                    this.digits = this.defaultString.split('');\n                }\n            } else {\n                // Control flashing of the score on reaching acheivement.\n                if (this.flashIterations <= this.config.FLASH_ITERATIONS) {\n                    this.flashTimer += deltaTime;\n\n                    if (this.flashTimer < this.config.FLASH_DURATION) {\n                        paint = false;\n                    } else if (this.flashTimer >\n                        this.config.FLASH_DURATION * 2) {\n                        this.flashTimer = 0;\n                        this.flashIterations++;\n                    }\n                } else {\n                    this.acheivement = false;\n                    this.flashIterations = 0;\n                    this.flashTimer = 0;\n                }\n            }\n\n            // Draw the digits if not flashing.\n            if (paint) {\n                for (var i = this.digits.length - 1; i >= 0; i--) {\n                    this.draw(i, parseInt(this.digits[i]));\n                }\n            }\n\n            this.drawHighScore();\n            return playSound;\n        },\n\n        /**\n         * Draw the high score.\n         */\n        drawHighScore: function () {\n            this.canvasCtx.save();\n            this.canvasCtx.globalAlpha = .8;\n            for (var i = this.highScore.length - 1; i >= 0; i--) {\n                this.draw(i, parseInt(this.highScore[i], 10), true);\n            }\n            this.canvasCtx.restore();\n        },\n\n        /**\n         * Set the highscore as a array string.\n         * Position of char in the sprite: H - 10, I - 11.\n         * @param {number} distance Distance ran in pixels.\n         */\n        setHighScore: function (distance) {\n            distance = this.getActualDistance(distance);\n            var highScoreStr = (this.defaultString +\n                distance).substr(-this.maxScoreUnits);\n\n            this.highScore = ['10', '11', ''].concat(highScoreStr.split(''));\n        },\n\n        /**\n         * Reset the distance meter back to '00000'.\n         */\n        reset: function () {\n            this.update(0);\n            this.acheivement = false;\n        }\n    };\n\n\n    //******************************************************************************\n\n    /**\n     * Cloud background item.\n     * Similar to an obstacle object but without collision boxes.\n     * @param {HTMLCanvasElement} canvas Canvas element.\n     * @param {Object} spritePos Position of image in sprite.\n     * @param {number} containerWidth\n     */\n    function Cloud(canvas, spritePos, containerWidth) {\n        this.canvas = canvas;\n        this.canvasCtx = this.canvas.getContext('2d');\n        this.spritePos = spritePos;\n        this.containerWidth = containerWidth;\n        this.xPos = containerWidth;\n        this.yPos = 0;\n        this.remove = false;\n        this.cloudGap = getRandomNum(Cloud.config.MIN_CLOUD_GAP,\n            Cloud.config.MAX_CLOUD_GAP);\n\n        this.init();\n    };\n\n\n    /**\n     * Cloud object config.\n     * @enum {number}\n     */\n    Cloud.config = {\n        HEIGHT: 14,\n        MAX_CLOUD_GAP: 400,\n        MAX_SKY_LEVEL: 30,\n        MIN_CLOUD_GAP: 100,\n        MIN_SKY_LEVEL: 71,\n        WIDTH: 46\n    };\n\n\n    Cloud.prototype = {\n        /**\n         * Initialise the cloud. Sets the Cloud height.\n         */\n        init: function () {\n            this.yPos = getRandomNum(Cloud.config.MAX_SKY_LEVEL,\n                Cloud.config.MIN_SKY_LEVEL);\n            this.draw();\n        },\n\n        /**\n         * Draw the cloud.\n         */\n        draw: function () {\n            this.canvasCtx.save();\n            var sourceWidth = Cloud.config.WIDTH;\n            var sourceHeight = Cloud.config.HEIGHT;\n\n            if (IS_HIDPI) {\n                sourceWidth = sourceWidth * 2;\n                sourceHeight = sourceHeight * 2;\n            }\n\n            this.canvasCtx.drawImage(Runner.imageSprite, this.spritePos.x,\n                this.spritePos.y,\n                sourceWidth, sourceHeight,\n                this.xPos, this.yPos,\n                Cloud.config.WIDTH, Cloud.config.HEIGHT);\n\n            this.canvasCtx.restore();\n        },\n\n        /**\n         * Update the cloud position.\n         * @param {number} speed\n         */\n        update: function (speed) {\n            if (!this.remove) {\n                this.xPos -= Math.ceil(speed);\n                this.draw();\n\n                // Mark as removeable if no longer in the canvas.\n                if (!this.isVisible()) {\n                    this.remove = true;\n                }\n            }\n        },\n\n        /**\n         * Check if the cloud is visible on the stage.\n         * @return {boolean}\n         */\n        isVisible: function () {\n            return this.xPos + Cloud.config.WIDTH > 0;\n        }\n    };\n\n\n    //******************************************************************************\n\n    /**\n     * Nightmode shows a moon and stars on the horizon.\n     */\n    function NightMode(canvas, spritePos, containerWidth) {\n        this.spritePos = spritePos;\n        this.canvas = canvas;\n        this.canvasCtx = canvas.getContext('2d');\n        this.xPos = containerWidth - 50;\n        this.yPos = 30;\n        this.currentPhase = 0;\n        this.opacity = 0;\n        this.containerWidth = containerWidth;\n        this.stars = [];\n        this.drawStars = false;\n        this.placeStars();\n    };\n\n    /**\n     * @enum {number}\n     */\n    NightMode.config = {\n        FADE_SPEED: 0.035,\n        HEIGHT: 40,\n        MOON_SPEED: 0.25,\n        NUM_STARS: 2,\n        STAR_SIZE: 9,\n        STAR_SPEED: 0.3,\n        STAR_MAX_Y: 70,\n        WIDTH: 20\n    };\n\n    NightMode.phases = [140, 120, 100, 60, 40, 20, 0];\n\n    NightMode.prototype = {\n        /**\n         * Update moving moon, changing phases.\n         * @param {boolean} activated Whether night mode is activated.\n         * @param {number} delta\n         */\n        update: function (activated, delta) {\n            // Moon phase.\n            if (activated && this.opacity == 0) {\n                this.currentPhase++;\n\n                if (this.currentPhase >= NightMode.phases.length) {\n                    this.currentPhase = 0;\n                }\n            }\n\n            // Fade in / out.\n            if (activated && (this.opacity < 1 || this.opacity == 0)) {\n                this.opacity += NightMode.config.FADE_SPEED;\n            } else if (this.opacity > 0) {\n                this.opacity -= NightMode.config.FADE_SPEED;\n            }\n\n            // Set moon positioning.\n            if (this.opacity > 0) {\n                this.xPos = this.updateXPos(this.xPos, NightMode.config.MOON_SPEED);\n\n                // Update stars.\n                if (this.drawStars) {\n                    for (var i = 0; i < NightMode.config.NUM_STARS; i++) {\n                        this.stars[i].x = this.updateXPos(this.stars[i].x,\n                            NightMode.config.STAR_SPEED);\n                    }\n                }\n                this.draw();\n            } else {\n                this.opacity = 0;\n                this.placeStars();\n            }\n            this.drawStars = true;\n        },\n\n        updateXPos: function (currentPos, speed) {\n            if (currentPos < -NightMode.config.WIDTH) {\n                currentPos = this.containerWidth;\n            } else {\n                currentPos -= speed;\n            }\n            return currentPos;\n        },\n\n        draw: function () {\n            var moonSourceWidth = this.currentPhase == 3 ? NightMode.config.WIDTH * 2 :\n                NightMode.config.WIDTH;\n            var moonSourceHeight = NightMode.config.HEIGHT;\n            var moonSourceX = this.spritePos.x + NightMode.phases[this.currentPhase];\n            var moonOutputWidth = moonSourceWidth;\n            var starSize = NightMode.config.STAR_SIZE;\n            var starSourceX = Runner.spriteDefinition.LDPI.STAR.x;\n\n            if (IS_HIDPI) {\n                moonSourceWidth *= 2;\n                moonSourceHeight *= 2;\n                moonSourceX = this.spritePos.x +\n                    (NightMode.phases[this.currentPhase] * 2);\n                starSize *= 2;\n                starSourceX = Runner.spriteDefinition.HDPI.STAR.x;\n            }\n\n            this.canvasCtx.save();\n            this.canvasCtx.globalAlpha = this.opacity;\n\n            // Stars.\n            if (this.drawStars) {\n                for (var i = 0; i < NightMode.config.NUM_STARS; i++) {\n                    this.canvasCtx.drawImage(Runner.imageSprite,\n                        starSourceX, this.stars[i].sourceY, starSize, starSize,\n                        Math.round(this.stars[i].x), this.stars[i].y,\n                        NightMode.config.STAR_SIZE, NightMode.config.STAR_SIZE);\n                }\n            }\n\n            // Moon.\n            this.canvasCtx.drawImage(Runner.imageSprite, moonSourceX,\n                this.spritePos.y, moonSourceWidth, moonSourceHeight,\n                Math.round(this.xPos), this.yPos,\n                moonOutputWidth, NightMode.config.HEIGHT);\n\n            this.canvasCtx.globalAlpha = 1;\n            this.canvasCtx.restore();\n        },\n\n        // Do star placement.\n        placeStars: function () {\n            var segmentSize = Math.round(this.containerWidth /\n                NightMode.config.NUM_STARS);\n\n            for (var i = 0; i < NightMode.config.NUM_STARS; i++) {\n                this.stars[i] = {};\n                this.stars[i].x = getRandomNum(segmentSize * i, segmentSize * (i + 1));\n                this.stars[i].y = getRandomNum(0, NightMode.config.STAR_MAX_Y);\n\n                if (IS_HIDPI) {\n                    this.stars[i].sourceY = Runner.spriteDefinition.HDPI.STAR.y +\n                        NightMode.config.STAR_SIZE * 2 * i;\n                } else {\n                    this.stars[i].sourceY = Runner.spriteDefinition.LDPI.STAR.y +\n                        NightMode.config.STAR_SIZE * i;\n                }\n            }\n        },\n\n        reset: function () {\n            this.currentPhase = 0;\n            this.opacity = 0;\n            this.update(false);\n        }\n\n    };\n\n\n    //******************************************************************************\n\n    /**\n     * Horizon Line.\n     * Consists of two connecting lines. Randomly assigns a flat / bumpy horizon.\n     * @param {HTMLCanvasElement} canvas\n     * @param {Object} spritePos Horizon position in sprite.\n     * @constructor\n     */\n    function HorizonLine(canvas, spritePos) {\n        this.spritePos = spritePos;\n        this.canvas = canvas;\n        this.canvasCtx = canvas.getContext('2d');\n        this.sourceDimensions = {};\n        this.dimensions = HorizonLine.dimensions;\n        this.sourceXPos = [this.spritePos.x, this.spritePos.x +\n            this.dimensions.WIDTH];\n        this.xPos = [];\n        this.yPos = 0;\n        this.bumpThreshold = 0.5;\n\n        this.setSourceDimensions();\n        this.draw();\n    };\n\n\n    /**\n     * Horizon line dimensions.\n     * @enum {number}\n     */\n    HorizonLine.dimensions = {\n        WIDTH: 600,\n        HEIGHT: 12,\n        YPOS: 127\n    };\n\n\n    HorizonLine.prototype = {\n        /**\n         * Set the source dimensions of the horizon line.\n         */\n        setSourceDimensions: function () {\n\n            for (var dimension in HorizonLine.dimensions) {\n                if (IS_HIDPI) {\n                    if (dimension != 'YPOS') {\n                        this.sourceDimensions[dimension] =\n                            HorizonLine.dimensions[dimension] * 2;\n                    }\n                } else {\n                    this.sourceDimensions[dimension] =\n                        HorizonLine.dimensions[dimension];\n                }\n                this.dimensions[dimension] = HorizonLine.dimensions[dimension];\n            }\n\n            this.xPos = [0, HorizonLine.dimensions.WIDTH];\n            this.yPos = HorizonLine.dimensions.YPOS;\n        },\n\n        /**\n         * Return the crop x position of a type.\n         */\n        getRandomType: function () {\n            return Math.random() > this.bumpThreshold ? this.dimensions.WIDTH : 0;\n        },\n\n        /**\n         * Draw the horizon line.\n         */\n        draw: function () {\n            this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[0],\n                this.spritePos.y,\n                this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,\n                this.xPos[0], this.yPos,\n                this.dimensions.WIDTH, this.dimensions.HEIGHT);\n\n            this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[1],\n                this.spritePos.y,\n                this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,\n                this.xPos[1], this.yPos,\n                this.dimensions.WIDTH, this.dimensions.HEIGHT);\n        },\n\n        /**\n         * Update the x position of an indivdual piece of the line.\n         * @param {number} pos Line position.\n         * @param {number} increment\n         */\n        updateXPos: function (pos, increment) {\n            var line1 = pos;\n            var line2 = pos == 0 ? 1 : 0;\n\n            this.xPos[line1] -= increment;\n            this.xPos[line2] = this.xPos[line1] + this.dimensions.WIDTH;\n\n            if (this.xPos[line1] <= -this.dimensions.WIDTH) {\n                this.xPos[line1] += this.dimensions.WIDTH * 2;\n                this.xPos[line2] = this.xPos[line1] - this.dimensions.WIDTH;\n                this.sourceXPos[line1] = this.getRandomType() + this.spritePos.x;\n            }\n        },\n\n        /**\n         * Update the horizon line.\n         * @param {number} deltaTime\n         * @param {number} speed\n         */\n        update: function (deltaTime, speed) {\n            var increment = Math.floor(speed * (FPS / 1000) * deltaTime);\n\n            if (this.xPos[0] <= 0) {\n                this.updateXPos(0, increment);\n            } else {\n                this.updateXPos(1, increment);\n            }\n            this.draw();\n        },\n\n        /**\n         * Reset horizon to the starting position.\n         */\n        reset: function () {\n            this.xPos[0] = 0;\n            this.xPos[1] = HorizonLine.dimensions.WIDTH;\n        }\n    };\n\n\n    //******************************************************************************\n\n    /**\n     * Horizon background class.\n     * @param {HTMLCanvasElement} canvas\n     * @param {Object} spritePos Sprite positioning.\n     * @param {Object} dimensions Canvas dimensions.\n     * @param {number} gapCoefficient\n     * @constructor\n     */\n    function Horizon(canvas, spritePos, dimensions, gapCoefficient) {\n        this.canvas = canvas;\n        this.canvasCtx = this.canvas.getContext('2d');\n        this.config = Horizon.config;\n        this.dimensions = dimensions;\n        this.gapCoefficient = gapCoefficient;\n        this.obstacles = [];\n        this.obstacleHistory = [];\n        this.horizonOffsets = [0, 0];\n        this.cloudFrequency = this.config.CLOUD_FREQUENCY;\n        this.spritePos = spritePos;\n        this.nightMode = null;\n\n        // Cloud\n        this.clouds = [];\n        this.cloudSpeed = this.config.BG_CLOUD_SPEED;\n\n        // Horizon\n        this.horizonLine = null;\n        this.init();\n    };\n\n\n    /**\n     * Horizon config.\n     * @enum {number}\n     */\n    Horizon.config = {\n        BG_CLOUD_SPEED: 0.2,\n        BUMPY_THRESHOLD: .3,\n        CLOUD_FREQUENCY: .5,\n        HORIZON_HEIGHT: 16,\n        MAX_CLOUDS: 6\n    };\n\n\n    Horizon.prototype = {\n        /**\n         * Initialise the horizon. Just add the line and a cloud. No obstacles.\n         */\n        init: function () {\n            this.addCloud();\n            this.horizonLine = new HorizonLine(this.canvas, this.spritePos.HORIZON);\n            this.nightMode = new NightMode(this.canvas, this.spritePos.MOON,\n                this.dimensions.WIDTH);\n        },\n\n        /**\n         * @param {number} deltaTime\n         * @param {number} currentSpeed\n         * @param {boolean} updateObstacles Used as an override to prevent\n         *     the obstacles from being updated / added. This happens in the\n         *     ease in section.\n         * @param {boolean} showNightMode Night mode activated.\n         */\n        update: function (deltaTime, currentSpeed, updateObstacles, showNightMode) {\n            this.runningTime += deltaTime;\n            this.horizonLine.update(deltaTime, currentSpeed);\n            this.nightMode.update(showNightMode);\n            this.updateClouds(deltaTime, currentSpeed);\n\n            if (updateObstacles) {\n                this.updateObstacles(deltaTime, currentSpeed);\n            }\n        },\n\n        /**\n         * Update the cloud positions.\n         * @param {number} deltaTime\n         * @param {number} currentSpeed\n         */\n        updateClouds: function (deltaTime, speed) {\n            var cloudSpeed = this.cloudSpeed / 1000 * deltaTime * speed;\n            var numClouds = this.clouds.length;\n\n            if (numClouds) {\n                for (var i = numClouds - 1; i >= 0; i--) {\n                    this.clouds[i].update(cloudSpeed);\n                }\n\n                var lastCloud = this.clouds[numClouds - 1];\n\n                // Check for adding a new cloud.\n                if (numClouds < this.config.MAX_CLOUDS &&\n                    (this.dimensions.WIDTH - lastCloud.xPos) > lastCloud.cloudGap &&\n                    this.cloudFrequency > Math.random()) {\n                    this.addCloud();\n                }\n\n                // Remove expired clouds.\n                this.clouds = this.clouds.filter(function (obj) {\n                    return !obj.remove;\n                });\n            } else {\n                this.addCloud();\n            }\n        },\n\n        /**\n         * Update the obstacle positions.\n         * @param {number} deltaTime\n         * @param {number} currentSpeed\n         */\n        updateObstacles: function (deltaTime, currentSpeed) {\n            // Obstacles, move to Horizon layer.\n            var updatedObstacles = this.obstacles.slice(0);\n\n            for (var i = 0; i < this.obstacles.length; i++) {\n                var obstacle = this.obstacles[i];\n                obstacle.update(deltaTime, currentSpeed);\n\n                // Clean up existing obstacles.\n                if (obstacle.remove) {\n                    updatedObstacles.shift();\n                }\n            }\n            this.obstacles = updatedObstacles;\n\n            if (this.obstacles.length > 0) {\n                var lastObstacle = this.obstacles[this.obstacles.length - 1];\n\n                if (lastObstacle && !lastObstacle.followingObstacleCreated &&\n                    lastObstacle.isVisible() &&\n                    (lastObstacle.xPos + lastObstacle.width + lastObstacle.gap) <\n                    this.dimensions.WIDTH) {\n                    this.addNewObstacle(currentSpeed);\n                    lastObstacle.followingObstacleCreated = true;\n                }\n            } else {\n                // Create new obstacles.\n                this.addNewObstacle(currentSpeed);\n            }\n        },\n\n        removeFirstObstacle: function () {\n            this.obstacles.shift();\n        },\n\n        /**\n         * Add a new obstacle.\n         * @param {number} currentSpeed\n         */\n        addNewObstacle: function (currentSpeed) {\n            var obstacleTypeIndex = getRandomNum(0, Obstacle.types.length - 1);\n            var obstacleType = Obstacle.types[obstacleTypeIndex];\n\n            // Check for multiples of the same type of obstacle.\n            // Also check obstacle is available at current speed.\n            if (this.duplicateObstacleCheck(obstacleType.type) ||\n                currentSpeed < obstacleType.minSpeed) {\n                this.addNewObstacle(currentSpeed);\n            } else {\n                var obstacleSpritePos = this.spritePos[obstacleType.type];\n\n                this.obstacles.push(new Obstacle(this.canvasCtx, obstacleType,\n                    obstacleSpritePos, this.dimensions,\n                    this.gapCoefficient, currentSpeed, obstacleType.width));\n\n                this.obstacleHistory.unshift(obstacleType.type);\n\n                if (this.obstacleHistory.length > 1) {\n                    this.obstacleHistory.splice(Runner.config.MAX_OBSTACLE_DUPLICATION);\n                }\n            }\n        },\n\n        /**\n         * Returns whether the previous two obstacles are the same as the next one.\n         * Maximum duplication is set in config value MAX_OBSTACLE_DUPLICATION.\n         * @return {boolean}\n         */\n        duplicateObstacleCheck: function (nextObstacleType) {\n            var duplicateCount = 0;\n\n            for (var i = 0; i < this.obstacleHistory.length; i++) {\n                duplicateCount = this.obstacleHistory[i] == nextObstacleType ?\n                    duplicateCount + 1 : 0;\n            }\n            return duplicateCount >= Runner.config.MAX_OBSTACLE_DUPLICATION;\n        },\n\n        /**\n         * Reset the horizon layer.\n         * Remove existing obstacles and reposition the horizon line.\n         */\n        reset: function () {\n            this.obstacles = [];\n            this.horizonLine.reset();\n            this.nightMode.reset();\n        },\n\n        /**\n         * Update the canvas width and scaling.\n         * @param {number} width Canvas width.\n         * @param {number} height Canvas height.\n         */\n        resize: function (width, height) {\n            this.canvas.width = width;\n            this.canvas.height = height;\n        },\n\n        /**\n         * Add a new cloud to the horizon.\n         */\n        addCloud: function () {\n            this.clouds.push(new Cloud(this.canvas, this.spritePos.CLOUD,\n                this.dimensions.WIDTH));\n        }\n    };\n})();\n\n\nfunction onDocumentLoad() {\n    new Runner('.interstitial-wrapper');\n}\n\ndocument.addEventListener('DOMContentLoaded', onDocumentLoad);\n"],"names":["Runner1","outerContainerId","opt_config","instance_","outerContainerEl","document","querySelector","containerEl","snackbarEl","detailsButton","config","dimensions","defaultDimensions","canvas","canvasCtx","tRex","distanceMeter","distanceRan","highestScore","time","runningTime","msPerFrame","FPS","currentSpeed","SPEED","obstacles","activated","playing","crashed","paused","inverted","invertTimer","resizeTimerId_","playCount","audioBuffer","soundFx","audioContext","images","imagesLoaded","isDisabled","setupDisabledRunner","loadImages","window","IS_HIDPI","devicePixelRatio","IS_IOS","test","navigator","platform","IS_MOBILE","userAgent","getRandomNum","min","max","Math","floor","random","getTimeStamp","Date","getTime","performance","now","GameOverPanel","textImgPos","restartImgPos","getContext","canvasDimensions","draw","createAdjustedCollisionBox","box","adjustment","CollisionBox","x","y","width","height","boxCompare","tRexBox","obstacleBox","obstacleBoxX","w","h","Obstacle","type","spriteImgPos","gapCoefficient","speed","opt_xOffset","spritePos","typeConfig","size","MAX_OBSTACLE_LENGTH","remove","xPos","WIDTH","yPos","collisionBoxes","gap","speedOffset","currentFrame","timer","init","Trex","groundYPos","currentAnimFrames","blinkDelay","blinkCount","animStartTime","status","WAITING","jumping","ducking","jumpVelocity","reachedMinHeight","speedDrop","jumpCount","jumpspotX","DistanceMeter","canvasWidth","image","imageSprite","currentDistance","maxScore","highScore","container","digits","acheivement","defaultString","flashTimer","flashIterations","invertTrigger","maxScoreUnits","MAX_DISTANCE_UNITS","Cloud","containerWidth","cloudGap","MIN_CLOUD_GAP","MAX_CLOUD_GAP","NightMode","currentPhase","opacity","stars","drawStars","placeStars","HorizonLine","sourceDimensions","sourceXPos","bumpThreshold","setSourceDimensions","Horizon","obstacleHistory","horizonOffsets","cloudFrequency","CLOUD_FREQUENCY","nightMode","clouds","cloudSpeed","BG_CLOUD_SPEED","horizonLine","ACCELERATION","BOTTOM_PAD","CLEAR_TIME","GAMEOVER_CLEAR_TIME","GAP_COEFFICIENT","GRAVITY","INITIAL_JUMP_VELOCITY","INVERT_FADE_DURATION","INVERT_DISTANCE","MAX_BLINK_COUNT","MAX_CLOUDS","MAX_OBSTACLE_DUPLICATION","MAX_SPEED","MIN_JUMP_HEIGHT","MOBILE_SPEED_COEFFICIENT","RESOURCE_TEMPLATE_ID","SPEED_DROP_COEFFICIENT","ARCADE_MODE_INITIAL_TOP_POSITION","ARCADE_MODE_TOP_POSITION_PERCENT","HEIGHT","classes","ARCADE_MODE","CANVAS","CONTAINER","CRASHED","ICON","INVERTED","SNACKBAR","SNACKBAR_SHOW","TOUCH_CONTROLLER","spriteDefinition","LDPI","CACTUS_LARGE","CACTUS_SMALL","CLOUD","HORIZON","MOON","PTERODACTYL","RESTART","TEXT_SPRITE","TREX","STAR","HDPI","sounds","BUTTON_PRESS","HIT","SCORE","keycodes","JUMP","DUCK","events","ANIM_END","CLICK","KEYDOWN","KEYUP","MOUSEDOWN","MOUSEUP","RESIZE","TOUCHEND","TOUCHSTART","VISIBILITY","BLUR","FOCUS","LOAD","prototype","createElement","className","textContent","loadTimeData","getValue","appendChild","addEventListener","e","keyCode","classList","add","bind","updateConfigSetting","setting","value","undefined","setJumpVelocity","setSpeed","getElementById","spriteDef","complete","loadSounds","AudioContext","resourceTemplate","content","sound","soundSrc","src","buffer","decodeBase64ToArrayBuffer","base64String","len","length","str","atob","bytes","Uint8Array","ArrayBuffer","i","charCodeAt","substr","indexOf","decodeAudioData","index","audioData","opt_speed","mobileSpeed","opt_classname","style","visibility","adjustDimensions","PLAYER","fillStyle","fill","updateCanvasScaling","horizon","createTouchController","startListening","update","debounceResize","touchController","setInterval","clearInterval","boxStyles","getComputedStyle","padding","Number","paddingLeft","offsetWidth","setArcadeModeContainerScale","calcXPos","clearCanvas","ceil","stop","gameOverPanel","updateDimensions","playIntro","restart","playingIntro","keyframes","sheet","innerHTML","head","startGame","webkitAnimation","setArcadeMode","onVisibilityChange","clearRect","updatePending","deltaTime","updateJump","hasObstacles","checkForCollision","obstacle","opt_canvasCtx","tRexCollisionBoxes","DUCKING","RUNNING","t","adjTrexBox","adjObstacleBox","gameOver","playSound","invert","actualDistance","getActualDistance","scheduleNextUpdate","handleEvent","evtType","onKeyDown","onKeyUp","stopListening","removeEventListener","preventDefault","target","errorPageController","trackEasterEgg","startJump","currentTarget","setSpeedDrop","setDuck","String","isjumpKey","isRunning","endJump","isLeftClickOnCanvas","reset","play","button","raqId","requestAnimationFrame","vibrate","setHighScore","cancelAnimationFrame","body","windowHeight","innerHeight","scale","innerWidth","translateY","transform","hidden","webkitHidden","visibilityState","soundBuffer","sourceNode","createBufferSource","connect","destination","start","toggle","opt_width","opt_height","context","backingStoreRatio","webkitBackingStorePixelRatio","ratio","oldWidth","oldHeight","TEXT_X","TEXT_Y","TEXT_WIDTH","TEXT_HEIGHT","RESTART_WIDTH","RESTART_HEIGHT","centerX","textSourceX","textSourceY","textSourceWidth","textSourceHeight","textTargetX","round","textTargetY","textTargetWidth","textTargetHeight","restartSourceWidth","restartSourceHeight","restartTargetX","restartTargetY","drawImage","MAX_GAP_COEFFICIENT","cloneCollisionBoxes","multipleSpeed","Array","isArray","yPosConfig","yPosMobile","getGap","sourceWidth","sourceHeight","sourceX","numFrames","frameRate","isVisible","minGap","maxGap","types","minSpeed","DROP_VELOCITY","HEIGHT_DUCK","INIITAL_JUMP_VELOCITY","INTRO_DURATION","MAX_JUMP_HEIGHT","SPRITE_WIDTH","START_X_POS","WIDTH_DUCK","JUMPING","BLINK_TIMING","animFrames","frames","minJumpHeight","opt_status","setBlinkDelay","blink","sourceY","framesElapsed","isDucking","midair","DEST_WIDTH","ACHIEVEMENT_DISTANCE","COEFFICIENT","FLASH_DURATION","FLASH_ITERATIONS","maxDistanceStr","parseInt","digitPos","opt_highScore","targetX","targetY","targetWidth","targetHeight","save","highScoreX","translate","restore","distance","paint","distanceStr","split","drawHighScore","globalAlpha","highScoreStr","concat","MAX_SKY_LEVEL","MIN_SKY_LEVEL","FADE_SPEED","MOON_SPEED","NUM_STARS","STAR_SIZE","STAR_SPEED","STAR_MAX_Y","phases","delta","updateXPos","currentPos","moonSourceWidth","moonSourceHeight","moonSourceX","moonOutputWidth","starSize","starSourceX","segmentSize","YPOS","dimension","getRandomType","pos","increment","line2","BUMPY_THRESHOLD","HORIZON_HEIGHT","addCloud","updateObstacles","showNightMode","updateClouds","numClouds","lastCloud","filter","obj","updatedObstacles","slice","shift","lastObstacle","followingObstacleCreated","addNewObstacle","removeFirstObstacle","obstacleTypeIndex","obstacleType","duplicateObstacleCheck","obstacleSpritePos","push","unshift","splice","nextObstacleType","duplicateCount","resize","Runner"],"version":3,"file":"index.3b645712.js.map"}